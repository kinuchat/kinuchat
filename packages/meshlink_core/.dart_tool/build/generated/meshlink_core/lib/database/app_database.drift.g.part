// ignore_for_file: type=lint
class $ContactsTable extends Contacts
    with TableInfo<$ContactsTable, ContactEntity> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ContactsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _displayNameMeta = const VerificationMeta(
    'displayName',
  );
  @override
  late final GeneratedColumn<String> displayName = GeneratedColumn<String>(
    'display_name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _avatarMeta = const VerificationMeta('avatar');
  @override
  late final GeneratedColumn<String> avatar = GeneratedColumn<String>(
    'avatar',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _publicKeyMeta = const VerificationMeta(
    'publicKey',
  );
  @override
  late final GeneratedColumn<String> publicKey = GeneratedColumn<String>(
    'public_key',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _exchangePublicKeyMeta = const VerificationMeta(
    'exchangePublicKey',
  );
  @override
  late final GeneratedColumn<String> exchangePublicKey =
      GeneratedColumn<String>(
        'exchange_public_key',
        aliasedName,
        false,
        type: DriftSqlType.string,
        requiredDuringInsert: true,
      );
  static const VerificationMeta _verificationStatusMeta =
      const VerificationMeta('verificationStatus');
  @override
  late final GeneratedColumn<String> verificationStatus =
      GeneratedColumn<String>(
        'verification_status',
        aliasedName,
        false,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
        defaultValue: const Constant('unverified'),
      );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _lastSeenMeta = const VerificationMeta(
    'lastSeen',
  );
  @override
  late final GeneratedColumn<DateTime> lastSeen = GeneratedColumn<DateTime>(
    'last_seen',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isBlockedMeta = const VerificationMeta(
    'isBlocked',
  );
  @override
  late final GeneratedColumn<bool> isBlocked = GeneratedColumn<bool>(
    'is_blocked',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_blocked" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _lastMeshRssiMeta = const VerificationMeta(
    'lastMeshRssi',
  );
  @override
  late final GeneratedColumn<int> lastMeshRssi = GeneratedColumn<int>(
    'last_mesh_rssi',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _lastMeshSeenMeta = const VerificationMeta(
    'lastMeshSeen',
  );
  @override
  late final GeneratedColumn<DateTime> lastMeshSeen = GeneratedColumn<DateTime>(
    'last_mesh_seen',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _lastMeshHopCountMeta = const VerificationMeta(
    'lastMeshHopCount',
  );
  @override
  late final GeneratedColumn<int> lastMeshHopCount = GeneratedColumn<int>(
    'last_mesh_hop_count',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _preferredTransportMeta =
      const VerificationMeta('preferredTransport');
  @override
  late final GeneratedColumn<String> preferredTransport =
      GeneratedColumn<String>(
        'preferred_transport',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    displayName,
    avatar,
    publicKey,
    exchangePublicKey,
    verificationStatus,
    createdAt,
    lastSeen,
    isBlocked,
    lastMeshRssi,
    lastMeshSeen,
    lastMeshHopCount,
    preferredTransport,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'contacts';
  @override
  VerificationContext validateIntegrity(
    Insertable<ContactEntity> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('display_name')) {
      context.handle(
        _displayNameMeta,
        displayName.isAcceptableOrUnknown(
          data['display_name']!,
          _displayNameMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_displayNameMeta);
    }
    if (data.containsKey('avatar')) {
      context.handle(
        _avatarMeta,
        avatar.isAcceptableOrUnknown(data['avatar']!, _avatarMeta),
      );
    }
    if (data.containsKey('public_key')) {
      context.handle(
        _publicKeyMeta,
        publicKey.isAcceptableOrUnknown(data['public_key']!, _publicKeyMeta),
      );
    } else if (isInserting) {
      context.missing(_publicKeyMeta);
    }
    if (data.containsKey('exchange_public_key')) {
      context.handle(
        _exchangePublicKeyMeta,
        exchangePublicKey.isAcceptableOrUnknown(
          data['exchange_public_key']!,
          _exchangePublicKeyMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_exchangePublicKeyMeta);
    }
    if (data.containsKey('verification_status')) {
      context.handle(
        _verificationStatusMeta,
        verificationStatus.isAcceptableOrUnknown(
          data['verification_status']!,
          _verificationStatusMeta,
        ),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('last_seen')) {
      context.handle(
        _lastSeenMeta,
        lastSeen.isAcceptableOrUnknown(data['last_seen']!, _lastSeenMeta),
      );
    }
    if (data.containsKey('is_blocked')) {
      context.handle(
        _isBlockedMeta,
        isBlocked.isAcceptableOrUnknown(data['is_blocked']!, _isBlockedMeta),
      );
    }
    if (data.containsKey('last_mesh_rssi')) {
      context.handle(
        _lastMeshRssiMeta,
        lastMeshRssi.isAcceptableOrUnknown(
          data['last_mesh_rssi']!,
          _lastMeshRssiMeta,
        ),
      );
    }
    if (data.containsKey('last_mesh_seen')) {
      context.handle(
        _lastMeshSeenMeta,
        lastMeshSeen.isAcceptableOrUnknown(
          data['last_mesh_seen']!,
          _lastMeshSeenMeta,
        ),
      );
    }
    if (data.containsKey('last_mesh_hop_count')) {
      context.handle(
        _lastMeshHopCountMeta,
        lastMeshHopCount.isAcceptableOrUnknown(
          data['last_mesh_hop_count']!,
          _lastMeshHopCountMeta,
        ),
      );
    }
    if (data.containsKey('preferred_transport')) {
      context.handle(
        _preferredTransportMeta,
        preferredTransport.isAcceptableOrUnknown(
          data['preferred_transport']!,
          _preferredTransportMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ContactEntity map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ContactEntity(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      displayName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}display_name'],
      )!,
      avatar: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}avatar'],
      ),
      publicKey: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}public_key'],
      )!,
      exchangePublicKey: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}exchange_public_key'],
      )!,
      verificationStatus: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}verification_status'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      lastSeen: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_seen'],
      ),
      isBlocked: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_blocked'],
      )!,
      lastMeshRssi: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}last_mesh_rssi'],
      ),
      lastMeshSeen: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_mesh_seen'],
      ),
      lastMeshHopCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}last_mesh_hop_count'],
      ),
      preferredTransport: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}preferred_transport'],
      ),
    );
  }

  @override
  $ContactsTable createAlias(String alias) {
    return $ContactsTable(attachedDatabase, alias);
  }
}

class ContactEntity extends DataClass implements Insertable<ContactEntity> {
  /// Unique contact ID (mesh peer ID or Matrix user ID)
  final String id;

  /// Display name
  final String displayName;

  /// Optional avatar URL or base64 data
  final String? avatar;

  /// Ed25519 public key (hex encoded)
  final String publicKey;

  /// X25519 public key for key exchange (hex encoded)
  final String exchangePublicKey;

  /// Verification status (verified, unverified)
  final String verificationStatus;

  /// When the contact was added
  final DateTime createdAt;

  /// Last time we saw this contact online
  final DateTime? lastSeen;

  /// Is this contact blocked
  final bool isBlocked;

  /// RSSI when last seen on mesh (signal strength in dBm)
  final int? lastMeshRssi;

  /// Last time seen via mesh network
  final DateTime? lastMeshSeen;

  /// Hop count when last reached via mesh
  final int? lastMeshHopCount;

  /// Preferred transport hint (cloud, mesh, bridge)
  final String? preferredTransport;
  const ContactEntity({
    required this.id,
    required this.displayName,
    this.avatar,
    required this.publicKey,
    required this.exchangePublicKey,
    required this.verificationStatus,
    required this.createdAt,
    this.lastSeen,
    required this.isBlocked,
    this.lastMeshRssi,
    this.lastMeshSeen,
    this.lastMeshHopCount,
    this.preferredTransport,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['display_name'] = Variable<String>(displayName);
    if (!nullToAbsent || avatar != null) {
      map['avatar'] = Variable<String>(avatar);
    }
    map['public_key'] = Variable<String>(publicKey);
    map['exchange_public_key'] = Variable<String>(exchangePublicKey);
    map['verification_status'] = Variable<String>(verificationStatus);
    map['created_at'] = Variable<DateTime>(createdAt);
    if (!nullToAbsent || lastSeen != null) {
      map['last_seen'] = Variable<DateTime>(lastSeen);
    }
    map['is_blocked'] = Variable<bool>(isBlocked);
    if (!nullToAbsent || lastMeshRssi != null) {
      map['last_mesh_rssi'] = Variable<int>(lastMeshRssi);
    }
    if (!nullToAbsent || lastMeshSeen != null) {
      map['last_mesh_seen'] = Variable<DateTime>(lastMeshSeen);
    }
    if (!nullToAbsent || lastMeshHopCount != null) {
      map['last_mesh_hop_count'] = Variable<int>(lastMeshHopCount);
    }
    if (!nullToAbsent || preferredTransport != null) {
      map['preferred_transport'] = Variable<String>(preferredTransport);
    }
    return map;
  }

  ContactsCompanion toCompanion(bool nullToAbsent) {
    return ContactsCompanion(
      id: Value(id),
      displayName: Value(displayName),
      avatar: avatar == null && nullToAbsent
          ? const Value.absent()
          : Value(avatar),
      publicKey: Value(publicKey),
      exchangePublicKey: Value(exchangePublicKey),
      verificationStatus: Value(verificationStatus),
      createdAt: Value(createdAt),
      lastSeen: lastSeen == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSeen),
      isBlocked: Value(isBlocked),
      lastMeshRssi: lastMeshRssi == null && nullToAbsent
          ? const Value.absent()
          : Value(lastMeshRssi),
      lastMeshSeen: lastMeshSeen == null && nullToAbsent
          ? const Value.absent()
          : Value(lastMeshSeen),
      lastMeshHopCount: lastMeshHopCount == null && nullToAbsent
          ? const Value.absent()
          : Value(lastMeshHopCount),
      preferredTransport: preferredTransport == null && nullToAbsent
          ? const Value.absent()
          : Value(preferredTransport),
    );
  }

  factory ContactEntity.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ContactEntity(
      id: serializer.fromJson<String>(json['id']),
      displayName: serializer.fromJson<String>(json['displayName']),
      avatar: serializer.fromJson<String?>(json['avatar']),
      publicKey: serializer.fromJson<String>(json['publicKey']),
      exchangePublicKey: serializer.fromJson<String>(json['exchangePublicKey']),
      verificationStatus: serializer.fromJson<String>(
        json['verificationStatus'],
      ),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      lastSeen: serializer.fromJson<DateTime?>(json['lastSeen']),
      isBlocked: serializer.fromJson<bool>(json['isBlocked']),
      lastMeshRssi: serializer.fromJson<int?>(json['lastMeshRssi']),
      lastMeshSeen: serializer.fromJson<DateTime?>(json['lastMeshSeen']),
      lastMeshHopCount: serializer.fromJson<int?>(json['lastMeshHopCount']),
      preferredTransport: serializer.fromJson<String?>(
        json['preferredTransport'],
      ),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'displayName': serializer.toJson<String>(displayName),
      'avatar': serializer.toJson<String?>(avatar),
      'publicKey': serializer.toJson<String>(publicKey),
      'exchangePublicKey': serializer.toJson<String>(exchangePublicKey),
      'verificationStatus': serializer.toJson<String>(verificationStatus),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'lastSeen': serializer.toJson<DateTime?>(lastSeen),
      'isBlocked': serializer.toJson<bool>(isBlocked),
      'lastMeshRssi': serializer.toJson<int?>(lastMeshRssi),
      'lastMeshSeen': serializer.toJson<DateTime?>(lastMeshSeen),
      'lastMeshHopCount': serializer.toJson<int?>(lastMeshHopCount),
      'preferredTransport': serializer.toJson<String?>(preferredTransport),
    };
  }

  ContactEntity copyWith({
    String? id,
    String? displayName,
    Value<String?> avatar = const Value.absent(),
    String? publicKey,
    String? exchangePublicKey,
    String? verificationStatus,
    DateTime? createdAt,
    Value<DateTime?> lastSeen = const Value.absent(),
    bool? isBlocked,
    Value<int?> lastMeshRssi = const Value.absent(),
    Value<DateTime?> lastMeshSeen = const Value.absent(),
    Value<int?> lastMeshHopCount = const Value.absent(),
    Value<String?> preferredTransport = const Value.absent(),
  }) => ContactEntity(
    id: id ?? this.id,
    displayName: displayName ?? this.displayName,
    avatar: avatar.present ? avatar.value : this.avatar,
    publicKey: publicKey ?? this.publicKey,
    exchangePublicKey: exchangePublicKey ?? this.exchangePublicKey,
    verificationStatus: verificationStatus ?? this.verificationStatus,
    createdAt: createdAt ?? this.createdAt,
    lastSeen: lastSeen.present ? lastSeen.value : this.lastSeen,
    isBlocked: isBlocked ?? this.isBlocked,
    lastMeshRssi: lastMeshRssi.present ? lastMeshRssi.value : this.lastMeshRssi,
    lastMeshSeen: lastMeshSeen.present ? lastMeshSeen.value : this.lastMeshSeen,
    lastMeshHopCount: lastMeshHopCount.present
        ? lastMeshHopCount.value
        : this.lastMeshHopCount,
    preferredTransport: preferredTransport.present
        ? preferredTransport.value
        : this.preferredTransport,
  );
  ContactEntity copyWithCompanion(ContactsCompanion data) {
    return ContactEntity(
      id: data.id.present ? data.id.value : this.id,
      displayName: data.displayName.present
          ? data.displayName.value
          : this.displayName,
      avatar: data.avatar.present ? data.avatar.value : this.avatar,
      publicKey: data.publicKey.present ? data.publicKey.value : this.publicKey,
      exchangePublicKey: data.exchangePublicKey.present
          ? data.exchangePublicKey.value
          : this.exchangePublicKey,
      verificationStatus: data.verificationStatus.present
          ? data.verificationStatus.value
          : this.verificationStatus,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      lastSeen: data.lastSeen.present ? data.lastSeen.value : this.lastSeen,
      isBlocked: data.isBlocked.present ? data.isBlocked.value : this.isBlocked,
      lastMeshRssi: data.lastMeshRssi.present
          ? data.lastMeshRssi.value
          : this.lastMeshRssi,
      lastMeshSeen: data.lastMeshSeen.present
          ? data.lastMeshSeen.value
          : this.lastMeshSeen,
      lastMeshHopCount: data.lastMeshHopCount.present
          ? data.lastMeshHopCount.value
          : this.lastMeshHopCount,
      preferredTransport: data.preferredTransport.present
          ? data.preferredTransport.value
          : this.preferredTransport,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ContactEntity(')
          ..write('id: $id, ')
          ..write('displayName: $displayName, ')
          ..write('avatar: $avatar, ')
          ..write('publicKey: $publicKey, ')
          ..write('exchangePublicKey: $exchangePublicKey, ')
          ..write('verificationStatus: $verificationStatus, ')
          ..write('createdAt: $createdAt, ')
          ..write('lastSeen: $lastSeen, ')
          ..write('isBlocked: $isBlocked, ')
          ..write('lastMeshRssi: $lastMeshRssi, ')
          ..write('lastMeshSeen: $lastMeshSeen, ')
          ..write('lastMeshHopCount: $lastMeshHopCount, ')
          ..write('preferredTransport: $preferredTransport')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    displayName,
    avatar,
    publicKey,
    exchangePublicKey,
    verificationStatus,
    createdAt,
    lastSeen,
    isBlocked,
    lastMeshRssi,
    lastMeshSeen,
    lastMeshHopCount,
    preferredTransport,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ContactEntity &&
          other.id == this.id &&
          other.displayName == this.displayName &&
          other.avatar == this.avatar &&
          other.publicKey == this.publicKey &&
          other.exchangePublicKey == this.exchangePublicKey &&
          other.verificationStatus == this.verificationStatus &&
          other.createdAt == this.createdAt &&
          other.lastSeen == this.lastSeen &&
          other.isBlocked == this.isBlocked &&
          other.lastMeshRssi == this.lastMeshRssi &&
          other.lastMeshSeen == this.lastMeshSeen &&
          other.lastMeshHopCount == this.lastMeshHopCount &&
          other.preferredTransport == this.preferredTransport);
}

class ContactsCompanion extends UpdateCompanion<ContactEntity> {
  final Value<String> id;
  final Value<String> displayName;
  final Value<String?> avatar;
  final Value<String> publicKey;
  final Value<String> exchangePublicKey;
  final Value<String> verificationStatus;
  final Value<DateTime> createdAt;
  final Value<DateTime?> lastSeen;
  final Value<bool> isBlocked;
  final Value<int?> lastMeshRssi;
  final Value<DateTime?> lastMeshSeen;
  final Value<int?> lastMeshHopCount;
  final Value<String?> preferredTransport;
  final Value<int> rowid;
  const ContactsCompanion({
    this.id = const Value.absent(),
    this.displayName = const Value.absent(),
    this.avatar = const Value.absent(),
    this.publicKey = const Value.absent(),
    this.exchangePublicKey = const Value.absent(),
    this.verificationStatus = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.lastSeen = const Value.absent(),
    this.isBlocked = const Value.absent(),
    this.lastMeshRssi = const Value.absent(),
    this.lastMeshSeen = const Value.absent(),
    this.lastMeshHopCount = const Value.absent(),
    this.preferredTransport = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ContactsCompanion.insert({
    required String id,
    required String displayName,
    this.avatar = const Value.absent(),
    required String publicKey,
    required String exchangePublicKey,
    this.verificationStatus = const Value.absent(),
    required DateTime createdAt,
    this.lastSeen = const Value.absent(),
    this.isBlocked = const Value.absent(),
    this.lastMeshRssi = const Value.absent(),
    this.lastMeshSeen = const Value.absent(),
    this.lastMeshHopCount = const Value.absent(),
    this.preferredTransport = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       displayName = Value(displayName),
       publicKey = Value(publicKey),
       exchangePublicKey = Value(exchangePublicKey),
       createdAt = Value(createdAt);
  static Insertable<ContactEntity> custom({
    Expression<String>? id,
    Expression<String>? displayName,
    Expression<String>? avatar,
    Expression<String>? publicKey,
    Expression<String>? exchangePublicKey,
    Expression<String>? verificationStatus,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? lastSeen,
    Expression<bool>? isBlocked,
    Expression<int>? lastMeshRssi,
    Expression<DateTime>? lastMeshSeen,
    Expression<int>? lastMeshHopCount,
    Expression<String>? preferredTransport,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (displayName != null) 'display_name': displayName,
      if (avatar != null) 'avatar': avatar,
      if (publicKey != null) 'public_key': publicKey,
      if (exchangePublicKey != null) 'exchange_public_key': exchangePublicKey,
      if (verificationStatus != null) 'verification_status': verificationStatus,
      if (createdAt != null) 'created_at': createdAt,
      if (lastSeen != null) 'last_seen': lastSeen,
      if (isBlocked != null) 'is_blocked': isBlocked,
      if (lastMeshRssi != null) 'last_mesh_rssi': lastMeshRssi,
      if (lastMeshSeen != null) 'last_mesh_seen': lastMeshSeen,
      if (lastMeshHopCount != null) 'last_mesh_hop_count': lastMeshHopCount,
      if (preferredTransport != null) 'preferred_transport': preferredTransport,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ContactsCompanion copyWith({
    Value<String>? id,
    Value<String>? displayName,
    Value<String?>? avatar,
    Value<String>? publicKey,
    Value<String>? exchangePublicKey,
    Value<String>? verificationStatus,
    Value<DateTime>? createdAt,
    Value<DateTime?>? lastSeen,
    Value<bool>? isBlocked,
    Value<int?>? lastMeshRssi,
    Value<DateTime?>? lastMeshSeen,
    Value<int?>? lastMeshHopCount,
    Value<String?>? preferredTransport,
    Value<int>? rowid,
  }) {
    return ContactsCompanion(
      id: id ?? this.id,
      displayName: displayName ?? this.displayName,
      avatar: avatar ?? this.avatar,
      publicKey: publicKey ?? this.publicKey,
      exchangePublicKey: exchangePublicKey ?? this.exchangePublicKey,
      verificationStatus: verificationStatus ?? this.verificationStatus,
      createdAt: createdAt ?? this.createdAt,
      lastSeen: lastSeen ?? this.lastSeen,
      isBlocked: isBlocked ?? this.isBlocked,
      lastMeshRssi: lastMeshRssi ?? this.lastMeshRssi,
      lastMeshSeen: lastMeshSeen ?? this.lastMeshSeen,
      lastMeshHopCount: lastMeshHopCount ?? this.lastMeshHopCount,
      preferredTransport: preferredTransport ?? this.preferredTransport,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (displayName.present) {
      map['display_name'] = Variable<String>(displayName.value);
    }
    if (avatar.present) {
      map['avatar'] = Variable<String>(avatar.value);
    }
    if (publicKey.present) {
      map['public_key'] = Variable<String>(publicKey.value);
    }
    if (exchangePublicKey.present) {
      map['exchange_public_key'] = Variable<String>(exchangePublicKey.value);
    }
    if (verificationStatus.present) {
      map['verification_status'] = Variable<String>(verificationStatus.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (lastSeen.present) {
      map['last_seen'] = Variable<DateTime>(lastSeen.value);
    }
    if (isBlocked.present) {
      map['is_blocked'] = Variable<bool>(isBlocked.value);
    }
    if (lastMeshRssi.present) {
      map['last_mesh_rssi'] = Variable<int>(lastMeshRssi.value);
    }
    if (lastMeshSeen.present) {
      map['last_mesh_seen'] = Variable<DateTime>(lastMeshSeen.value);
    }
    if (lastMeshHopCount.present) {
      map['last_mesh_hop_count'] = Variable<int>(lastMeshHopCount.value);
    }
    if (preferredTransport.present) {
      map['preferred_transport'] = Variable<String>(preferredTransport.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ContactsCompanion(')
          ..write('id: $id, ')
          ..write('displayName: $displayName, ')
          ..write('avatar: $avatar, ')
          ..write('publicKey: $publicKey, ')
          ..write('exchangePublicKey: $exchangePublicKey, ')
          ..write('verificationStatus: $verificationStatus, ')
          ..write('createdAt: $createdAt, ')
          ..write('lastSeen: $lastSeen, ')
          ..write('isBlocked: $isBlocked, ')
          ..write('lastMeshRssi: $lastMeshRssi, ')
          ..write('lastMeshSeen: $lastMeshSeen, ')
          ..write('lastMeshHopCount: $lastMeshHopCount, ')
          ..write('preferredTransport: $preferredTransport, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ConversationsTable extends Conversations
    with TableInfo<$ConversationsTable, ConversationEntity> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ConversationsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _typeMeta = const VerificationMeta('type');
  @override
  late final GeneratedColumn<String> type = GeneratedColumn<String>(
    'type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _avatarMeta = const VerificationMeta('avatar');
  @override
  late final GeneratedColumn<String> avatar = GeneratedColumn<String>(
    'avatar',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _lastMessageAtMeta = const VerificationMeta(
    'lastMessageAt',
  );
  @override
  late final GeneratedColumn<DateTime> lastMessageAt =
      GeneratedColumn<DateTime>(
        'last_message_at',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _unreadCountMeta = const VerificationMeta(
    'unreadCount',
  );
  @override
  late final GeneratedColumn<int> unreadCount = GeneratedColumn<int>(
    'unread_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _isMutedMeta = const VerificationMeta(
    'isMuted',
  );
  @override
  late final GeneratedColumn<bool> isMuted = GeneratedColumn<bool>(
    'is_muted',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_muted" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _isArchivedMeta = const VerificationMeta(
    'isArchived',
  );
  @override
  late final GeneratedColumn<bool> isArchived = GeneratedColumn<bool>(
    'is_archived',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_archived" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _centroidLatitudeMeta = const VerificationMeta(
    'centroidLatitude',
  );
  @override
  late final GeneratedColumn<double> centroidLatitude = GeneratedColumn<double>(
    'centroid_latitude',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _centroidLongitudeMeta = const VerificationMeta(
    'centroidLongitude',
  );
  @override
  late final GeneratedColumn<double> centroidLongitude =
      GeneratedColumn<double>(
        'centroid_longitude',
        aliasedName,
        true,
        type: DriftSqlType.double,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _channelRadiusMetersMeta =
      const VerificationMeta('channelRadiusMeters');
  @override
  late final GeneratedColumn<int> channelRadiusMeters = GeneratedColumn<int>(
    'channel_radius_meters',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _geohashMeta = const VerificationMeta(
    'geohash',
  );
  @override
  late final GeneratedColumn<String> geohash = GeneratedColumn<String>(
    'geohash',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _creatorIdMeta = const VerificationMeta(
    'creatorId',
  );
  @override
  late final GeneratedColumn<String> creatorId = GeneratedColumn<String>(
    'creator_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _maxMessageAgeHoursMeta =
      const VerificationMeta('maxMessageAgeHours');
  @override
  late final GeneratedColumn<int> maxMessageAgeHours = GeneratedColumn<int>(
    'max_message_age_hours',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isPublicMeta = const VerificationMeta(
    'isPublic',
  );
  @override
  late final GeneratedColumn<bool> isPublic = GeneratedColumn<bool>(
    'is_public',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_public" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _participantCountMeta = const VerificationMeta(
    'participantCount',
  );
  @override
  late final GeneratedColumn<int> participantCount = GeneratedColumn<int>(
    'participant_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    type,
    name,
    avatar,
    createdAt,
    lastMessageAt,
    unreadCount,
    isMuted,
    isArchived,
    centroidLatitude,
    centroidLongitude,
    channelRadiusMeters,
    geohash,
    creatorId,
    maxMessageAgeHours,
    isPublic,
    participantCount,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'conversations';
  @override
  VerificationContext validateIntegrity(
    Insertable<ConversationEntity> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('type')) {
      context.handle(
        _typeMeta,
        type.isAcceptableOrUnknown(data['type']!, _typeMeta),
      );
    } else if (isInserting) {
      context.missing(_typeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    }
    if (data.containsKey('avatar')) {
      context.handle(
        _avatarMeta,
        avatar.isAcceptableOrUnknown(data['avatar']!, _avatarMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('last_message_at')) {
      context.handle(
        _lastMessageAtMeta,
        lastMessageAt.isAcceptableOrUnknown(
          data['last_message_at']!,
          _lastMessageAtMeta,
        ),
      );
    }
    if (data.containsKey('unread_count')) {
      context.handle(
        _unreadCountMeta,
        unreadCount.isAcceptableOrUnknown(
          data['unread_count']!,
          _unreadCountMeta,
        ),
      );
    }
    if (data.containsKey('is_muted')) {
      context.handle(
        _isMutedMeta,
        isMuted.isAcceptableOrUnknown(data['is_muted']!, _isMutedMeta),
      );
    }
    if (data.containsKey('is_archived')) {
      context.handle(
        _isArchivedMeta,
        isArchived.isAcceptableOrUnknown(data['is_archived']!, _isArchivedMeta),
      );
    }
    if (data.containsKey('centroid_latitude')) {
      context.handle(
        _centroidLatitudeMeta,
        centroidLatitude.isAcceptableOrUnknown(
          data['centroid_latitude']!,
          _centroidLatitudeMeta,
        ),
      );
    }
    if (data.containsKey('centroid_longitude')) {
      context.handle(
        _centroidLongitudeMeta,
        centroidLongitude.isAcceptableOrUnknown(
          data['centroid_longitude']!,
          _centroidLongitudeMeta,
        ),
      );
    }
    if (data.containsKey('channel_radius_meters')) {
      context.handle(
        _channelRadiusMetersMeta,
        channelRadiusMeters.isAcceptableOrUnknown(
          data['channel_radius_meters']!,
          _channelRadiusMetersMeta,
        ),
      );
    }
    if (data.containsKey('geohash')) {
      context.handle(
        _geohashMeta,
        geohash.isAcceptableOrUnknown(data['geohash']!, _geohashMeta),
      );
    }
    if (data.containsKey('creator_id')) {
      context.handle(
        _creatorIdMeta,
        creatorId.isAcceptableOrUnknown(data['creator_id']!, _creatorIdMeta),
      );
    }
    if (data.containsKey('max_message_age_hours')) {
      context.handle(
        _maxMessageAgeHoursMeta,
        maxMessageAgeHours.isAcceptableOrUnknown(
          data['max_message_age_hours']!,
          _maxMessageAgeHoursMeta,
        ),
      );
    }
    if (data.containsKey('is_public')) {
      context.handle(
        _isPublicMeta,
        isPublic.isAcceptableOrUnknown(data['is_public']!, _isPublicMeta),
      );
    }
    if (data.containsKey('participant_count')) {
      context.handle(
        _participantCountMeta,
        participantCount.isAcceptableOrUnknown(
          data['participant_count']!,
          _participantCountMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ConversationEntity map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ConversationEntity(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      type: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}type'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      ),
      avatar: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}avatar'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      lastMessageAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_message_at'],
      ),
      unreadCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}unread_count'],
      )!,
      isMuted: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_muted'],
      )!,
      isArchived: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_archived'],
      )!,
      centroidLatitude: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}centroid_latitude'],
      ),
      centroidLongitude: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}centroid_longitude'],
      ),
      channelRadiusMeters: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}channel_radius_meters'],
      ),
      geohash: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}geohash'],
      ),
      creatorId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}creator_id'],
      ),
      maxMessageAgeHours: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}max_message_age_hours'],
      ),
      isPublic: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_public'],
      )!,
      participantCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}participant_count'],
      )!,
    );
  }

  @override
  $ConversationsTable createAlias(String alias) {
    return $ConversationsTable(attachedDatabase, alias);
  }
}

class ConversationEntity extends DataClass
    implements Insertable<ConversationEntity> {
  /// Unique conversation ID
  final String id;

  /// Conversation type (direct, group, rally)
  final String type;

  /// Display name for groups
  final String? name;

  /// Avatar for groups
  final String? avatar;

  /// When the conversation was created
  final DateTime createdAt;

  /// Last message timestamp
  final DateTime? lastMessageAt;

  /// Unread message count
  final int unreadCount;

  /// Is this conversation muted
  final bool isMuted;

  /// Is this conversation archived
  final bool isArchived;

  /// Rally channel center latitude
  final double? centroidLatitude;

  /// Rally channel center longitude
  final double? centroidLongitude;

  /// Rally channel coverage radius in meters
  final int? channelRadiusMeters;

  /// Rally channel geohash (precision 6 = ~1.2km)
  final String? geohash;

  /// Rally channel creator ID
  final String? creatorId;

  /// Rally message TTL in hours (default 4)
  final int? maxMessageAgeHours;

  /// Is this a public Rally channel
  final bool isPublic;

  /// Rally channel participant count
  final int participantCount;
  const ConversationEntity({
    required this.id,
    required this.type,
    this.name,
    this.avatar,
    required this.createdAt,
    this.lastMessageAt,
    required this.unreadCount,
    required this.isMuted,
    required this.isArchived,
    this.centroidLatitude,
    this.centroidLongitude,
    this.channelRadiusMeters,
    this.geohash,
    this.creatorId,
    this.maxMessageAgeHours,
    required this.isPublic,
    required this.participantCount,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['type'] = Variable<String>(type);
    if (!nullToAbsent || name != null) {
      map['name'] = Variable<String>(name);
    }
    if (!nullToAbsent || avatar != null) {
      map['avatar'] = Variable<String>(avatar);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    if (!nullToAbsent || lastMessageAt != null) {
      map['last_message_at'] = Variable<DateTime>(lastMessageAt);
    }
    map['unread_count'] = Variable<int>(unreadCount);
    map['is_muted'] = Variable<bool>(isMuted);
    map['is_archived'] = Variable<bool>(isArchived);
    if (!nullToAbsent || centroidLatitude != null) {
      map['centroid_latitude'] = Variable<double>(centroidLatitude);
    }
    if (!nullToAbsent || centroidLongitude != null) {
      map['centroid_longitude'] = Variable<double>(centroidLongitude);
    }
    if (!nullToAbsent || channelRadiusMeters != null) {
      map['channel_radius_meters'] = Variable<int>(channelRadiusMeters);
    }
    if (!nullToAbsent || geohash != null) {
      map['geohash'] = Variable<String>(geohash);
    }
    if (!nullToAbsent || creatorId != null) {
      map['creator_id'] = Variable<String>(creatorId);
    }
    if (!nullToAbsent || maxMessageAgeHours != null) {
      map['max_message_age_hours'] = Variable<int>(maxMessageAgeHours);
    }
    map['is_public'] = Variable<bool>(isPublic);
    map['participant_count'] = Variable<int>(participantCount);
    return map;
  }

  ConversationsCompanion toCompanion(bool nullToAbsent) {
    return ConversationsCompanion(
      id: Value(id),
      type: Value(type),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      avatar: avatar == null && nullToAbsent
          ? const Value.absent()
          : Value(avatar),
      createdAt: Value(createdAt),
      lastMessageAt: lastMessageAt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastMessageAt),
      unreadCount: Value(unreadCount),
      isMuted: Value(isMuted),
      isArchived: Value(isArchived),
      centroidLatitude: centroidLatitude == null && nullToAbsent
          ? const Value.absent()
          : Value(centroidLatitude),
      centroidLongitude: centroidLongitude == null && nullToAbsent
          ? const Value.absent()
          : Value(centroidLongitude),
      channelRadiusMeters: channelRadiusMeters == null && nullToAbsent
          ? const Value.absent()
          : Value(channelRadiusMeters),
      geohash: geohash == null && nullToAbsent
          ? const Value.absent()
          : Value(geohash),
      creatorId: creatorId == null && nullToAbsent
          ? const Value.absent()
          : Value(creatorId),
      maxMessageAgeHours: maxMessageAgeHours == null && nullToAbsent
          ? const Value.absent()
          : Value(maxMessageAgeHours),
      isPublic: Value(isPublic),
      participantCount: Value(participantCount),
    );
  }

  factory ConversationEntity.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ConversationEntity(
      id: serializer.fromJson<String>(json['id']),
      type: serializer.fromJson<String>(json['type']),
      name: serializer.fromJson<String?>(json['name']),
      avatar: serializer.fromJson<String?>(json['avatar']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      lastMessageAt: serializer.fromJson<DateTime?>(json['lastMessageAt']),
      unreadCount: serializer.fromJson<int>(json['unreadCount']),
      isMuted: serializer.fromJson<bool>(json['isMuted']),
      isArchived: serializer.fromJson<bool>(json['isArchived']),
      centroidLatitude: serializer.fromJson<double?>(json['centroidLatitude']),
      centroidLongitude: serializer.fromJson<double?>(
        json['centroidLongitude'],
      ),
      channelRadiusMeters: serializer.fromJson<int?>(
        json['channelRadiusMeters'],
      ),
      geohash: serializer.fromJson<String?>(json['geohash']),
      creatorId: serializer.fromJson<String?>(json['creatorId']),
      maxMessageAgeHours: serializer.fromJson<int?>(json['maxMessageAgeHours']),
      isPublic: serializer.fromJson<bool>(json['isPublic']),
      participantCount: serializer.fromJson<int>(json['participantCount']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'type': serializer.toJson<String>(type),
      'name': serializer.toJson<String?>(name),
      'avatar': serializer.toJson<String?>(avatar),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'lastMessageAt': serializer.toJson<DateTime?>(lastMessageAt),
      'unreadCount': serializer.toJson<int>(unreadCount),
      'isMuted': serializer.toJson<bool>(isMuted),
      'isArchived': serializer.toJson<bool>(isArchived),
      'centroidLatitude': serializer.toJson<double?>(centroidLatitude),
      'centroidLongitude': serializer.toJson<double?>(centroidLongitude),
      'channelRadiusMeters': serializer.toJson<int?>(channelRadiusMeters),
      'geohash': serializer.toJson<String?>(geohash),
      'creatorId': serializer.toJson<String?>(creatorId),
      'maxMessageAgeHours': serializer.toJson<int?>(maxMessageAgeHours),
      'isPublic': serializer.toJson<bool>(isPublic),
      'participantCount': serializer.toJson<int>(participantCount),
    };
  }

  ConversationEntity copyWith({
    String? id,
    String? type,
    Value<String?> name = const Value.absent(),
    Value<String?> avatar = const Value.absent(),
    DateTime? createdAt,
    Value<DateTime?> lastMessageAt = const Value.absent(),
    int? unreadCount,
    bool? isMuted,
    bool? isArchived,
    Value<double?> centroidLatitude = const Value.absent(),
    Value<double?> centroidLongitude = const Value.absent(),
    Value<int?> channelRadiusMeters = const Value.absent(),
    Value<String?> geohash = const Value.absent(),
    Value<String?> creatorId = const Value.absent(),
    Value<int?> maxMessageAgeHours = const Value.absent(),
    bool? isPublic,
    int? participantCount,
  }) => ConversationEntity(
    id: id ?? this.id,
    type: type ?? this.type,
    name: name.present ? name.value : this.name,
    avatar: avatar.present ? avatar.value : this.avatar,
    createdAt: createdAt ?? this.createdAt,
    lastMessageAt: lastMessageAt.present
        ? lastMessageAt.value
        : this.lastMessageAt,
    unreadCount: unreadCount ?? this.unreadCount,
    isMuted: isMuted ?? this.isMuted,
    isArchived: isArchived ?? this.isArchived,
    centroidLatitude: centroidLatitude.present
        ? centroidLatitude.value
        : this.centroidLatitude,
    centroidLongitude: centroidLongitude.present
        ? centroidLongitude.value
        : this.centroidLongitude,
    channelRadiusMeters: channelRadiusMeters.present
        ? channelRadiusMeters.value
        : this.channelRadiusMeters,
    geohash: geohash.present ? geohash.value : this.geohash,
    creatorId: creatorId.present ? creatorId.value : this.creatorId,
    maxMessageAgeHours: maxMessageAgeHours.present
        ? maxMessageAgeHours.value
        : this.maxMessageAgeHours,
    isPublic: isPublic ?? this.isPublic,
    participantCount: participantCount ?? this.participantCount,
  );
  ConversationEntity copyWithCompanion(ConversationsCompanion data) {
    return ConversationEntity(
      id: data.id.present ? data.id.value : this.id,
      type: data.type.present ? data.type.value : this.type,
      name: data.name.present ? data.name.value : this.name,
      avatar: data.avatar.present ? data.avatar.value : this.avatar,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      lastMessageAt: data.lastMessageAt.present
          ? data.lastMessageAt.value
          : this.lastMessageAt,
      unreadCount: data.unreadCount.present
          ? data.unreadCount.value
          : this.unreadCount,
      isMuted: data.isMuted.present ? data.isMuted.value : this.isMuted,
      isArchived: data.isArchived.present
          ? data.isArchived.value
          : this.isArchived,
      centroidLatitude: data.centroidLatitude.present
          ? data.centroidLatitude.value
          : this.centroidLatitude,
      centroidLongitude: data.centroidLongitude.present
          ? data.centroidLongitude.value
          : this.centroidLongitude,
      channelRadiusMeters: data.channelRadiusMeters.present
          ? data.channelRadiusMeters.value
          : this.channelRadiusMeters,
      geohash: data.geohash.present ? data.geohash.value : this.geohash,
      creatorId: data.creatorId.present ? data.creatorId.value : this.creatorId,
      maxMessageAgeHours: data.maxMessageAgeHours.present
          ? data.maxMessageAgeHours.value
          : this.maxMessageAgeHours,
      isPublic: data.isPublic.present ? data.isPublic.value : this.isPublic,
      participantCount: data.participantCount.present
          ? data.participantCount.value
          : this.participantCount,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ConversationEntity(')
          ..write('id: $id, ')
          ..write('type: $type, ')
          ..write('name: $name, ')
          ..write('avatar: $avatar, ')
          ..write('createdAt: $createdAt, ')
          ..write('lastMessageAt: $lastMessageAt, ')
          ..write('unreadCount: $unreadCount, ')
          ..write('isMuted: $isMuted, ')
          ..write('isArchived: $isArchived, ')
          ..write('centroidLatitude: $centroidLatitude, ')
          ..write('centroidLongitude: $centroidLongitude, ')
          ..write('channelRadiusMeters: $channelRadiusMeters, ')
          ..write('geohash: $geohash, ')
          ..write('creatorId: $creatorId, ')
          ..write('maxMessageAgeHours: $maxMessageAgeHours, ')
          ..write('isPublic: $isPublic, ')
          ..write('participantCount: $participantCount')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    type,
    name,
    avatar,
    createdAt,
    lastMessageAt,
    unreadCount,
    isMuted,
    isArchived,
    centroidLatitude,
    centroidLongitude,
    channelRadiusMeters,
    geohash,
    creatorId,
    maxMessageAgeHours,
    isPublic,
    participantCount,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ConversationEntity &&
          other.id == this.id &&
          other.type == this.type &&
          other.name == this.name &&
          other.avatar == this.avatar &&
          other.createdAt == this.createdAt &&
          other.lastMessageAt == this.lastMessageAt &&
          other.unreadCount == this.unreadCount &&
          other.isMuted == this.isMuted &&
          other.isArchived == this.isArchived &&
          other.centroidLatitude == this.centroidLatitude &&
          other.centroidLongitude == this.centroidLongitude &&
          other.channelRadiusMeters == this.channelRadiusMeters &&
          other.geohash == this.geohash &&
          other.creatorId == this.creatorId &&
          other.maxMessageAgeHours == this.maxMessageAgeHours &&
          other.isPublic == this.isPublic &&
          other.participantCount == this.participantCount);
}

class ConversationsCompanion extends UpdateCompanion<ConversationEntity> {
  final Value<String> id;
  final Value<String> type;
  final Value<String?> name;
  final Value<String?> avatar;
  final Value<DateTime> createdAt;
  final Value<DateTime?> lastMessageAt;
  final Value<int> unreadCount;
  final Value<bool> isMuted;
  final Value<bool> isArchived;
  final Value<double?> centroidLatitude;
  final Value<double?> centroidLongitude;
  final Value<int?> channelRadiusMeters;
  final Value<String?> geohash;
  final Value<String?> creatorId;
  final Value<int?> maxMessageAgeHours;
  final Value<bool> isPublic;
  final Value<int> participantCount;
  final Value<int> rowid;
  const ConversationsCompanion({
    this.id = const Value.absent(),
    this.type = const Value.absent(),
    this.name = const Value.absent(),
    this.avatar = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.lastMessageAt = const Value.absent(),
    this.unreadCount = const Value.absent(),
    this.isMuted = const Value.absent(),
    this.isArchived = const Value.absent(),
    this.centroidLatitude = const Value.absent(),
    this.centroidLongitude = const Value.absent(),
    this.channelRadiusMeters = const Value.absent(),
    this.geohash = const Value.absent(),
    this.creatorId = const Value.absent(),
    this.maxMessageAgeHours = const Value.absent(),
    this.isPublic = const Value.absent(),
    this.participantCount = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ConversationsCompanion.insert({
    required String id,
    required String type,
    this.name = const Value.absent(),
    this.avatar = const Value.absent(),
    required DateTime createdAt,
    this.lastMessageAt = const Value.absent(),
    this.unreadCount = const Value.absent(),
    this.isMuted = const Value.absent(),
    this.isArchived = const Value.absent(),
    this.centroidLatitude = const Value.absent(),
    this.centroidLongitude = const Value.absent(),
    this.channelRadiusMeters = const Value.absent(),
    this.geohash = const Value.absent(),
    this.creatorId = const Value.absent(),
    this.maxMessageAgeHours = const Value.absent(),
    this.isPublic = const Value.absent(),
    this.participantCount = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       type = Value(type),
       createdAt = Value(createdAt);
  static Insertable<ConversationEntity> custom({
    Expression<String>? id,
    Expression<String>? type,
    Expression<String>? name,
    Expression<String>? avatar,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? lastMessageAt,
    Expression<int>? unreadCount,
    Expression<bool>? isMuted,
    Expression<bool>? isArchived,
    Expression<double>? centroidLatitude,
    Expression<double>? centroidLongitude,
    Expression<int>? channelRadiusMeters,
    Expression<String>? geohash,
    Expression<String>? creatorId,
    Expression<int>? maxMessageAgeHours,
    Expression<bool>? isPublic,
    Expression<int>? participantCount,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (type != null) 'type': type,
      if (name != null) 'name': name,
      if (avatar != null) 'avatar': avatar,
      if (createdAt != null) 'created_at': createdAt,
      if (lastMessageAt != null) 'last_message_at': lastMessageAt,
      if (unreadCount != null) 'unread_count': unreadCount,
      if (isMuted != null) 'is_muted': isMuted,
      if (isArchived != null) 'is_archived': isArchived,
      if (centroidLatitude != null) 'centroid_latitude': centroidLatitude,
      if (centroidLongitude != null) 'centroid_longitude': centroidLongitude,
      if (channelRadiusMeters != null)
        'channel_radius_meters': channelRadiusMeters,
      if (geohash != null) 'geohash': geohash,
      if (creatorId != null) 'creator_id': creatorId,
      if (maxMessageAgeHours != null)
        'max_message_age_hours': maxMessageAgeHours,
      if (isPublic != null) 'is_public': isPublic,
      if (participantCount != null) 'participant_count': participantCount,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ConversationsCompanion copyWith({
    Value<String>? id,
    Value<String>? type,
    Value<String?>? name,
    Value<String?>? avatar,
    Value<DateTime>? createdAt,
    Value<DateTime?>? lastMessageAt,
    Value<int>? unreadCount,
    Value<bool>? isMuted,
    Value<bool>? isArchived,
    Value<double?>? centroidLatitude,
    Value<double?>? centroidLongitude,
    Value<int?>? channelRadiusMeters,
    Value<String?>? geohash,
    Value<String?>? creatorId,
    Value<int?>? maxMessageAgeHours,
    Value<bool>? isPublic,
    Value<int>? participantCount,
    Value<int>? rowid,
  }) {
    return ConversationsCompanion(
      id: id ?? this.id,
      type: type ?? this.type,
      name: name ?? this.name,
      avatar: avatar ?? this.avatar,
      createdAt: createdAt ?? this.createdAt,
      lastMessageAt: lastMessageAt ?? this.lastMessageAt,
      unreadCount: unreadCount ?? this.unreadCount,
      isMuted: isMuted ?? this.isMuted,
      isArchived: isArchived ?? this.isArchived,
      centroidLatitude: centroidLatitude ?? this.centroidLatitude,
      centroidLongitude: centroidLongitude ?? this.centroidLongitude,
      channelRadiusMeters: channelRadiusMeters ?? this.channelRadiusMeters,
      geohash: geohash ?? this.geohash,
      creatorId: creatorId ?? this.creatorId,
      maxMessageAgeHours: maxMessageAgeHours ?? this.maxMessageAgeHours,
      isPublic: isPublic ?? this.isPublic,
      participantCount: participantCount ?? this.participantCount,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (type.present) {
      map['type'] = Variable<String>(type.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (avatar.present) {
      map['avatar'] = Variable<String>(avatar.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (lastMessageAt.present) {
      map['last_message_at'] = Variable<DateTime>(lastMessageAt.value);
    }
    if (unreadCount.present) {
      map['unread_count'] = Variable<int>(unreadCount.value);
    }
    if (isMuted.present) {
      map['is_muted'] = Variable<bool>(isMuted.value);
    }
    if (isArchived.present) {
      map['is_archived'] = Variable<bool>(isArchived.value);
    }
    if (centroidLatitude.present) {
      map['centroid_latitude'] = Variable<double>(centroidLatitude.value);
    }
    if (centroidLongitude.present) {
      map['centroid_longitude'] = Variable<double>(centroidLongitude.value);
    }
    if (channelRadiusMeters.present) {
      map['channel_radius_meters'] = Variable<int>(channelRadiusMeters.value);
    }
    if (geohash.present) {
      map['geohash'] = Variable<String>(geohash.value);
    }
    if (creatorId.present) {
      map['creator_id'] = Variable<String>(creatorId.value);
    }
    if (maxMessageAgeHours.present) {
      map['max_message_age_hours'] = Variable<int>(maxMessageAgeHours.value);
    }
    if (isPublic.present) {
      map['is_public'] = Variable<bool>(isPublic.value);
    }
    if (participantCount.present) {
      map['participant_count'] = Variable<int>(participantCount.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ConversationsCompanion(')
          ..write('id: $id, ')
          ..write('type: $type, ')
          ..write('name: $name, ')
          ..write('avatar: $avatar, ')
          ..write('createdAt: $createdAt, ')
          ..write('lastMessageAt: $lastMessageAt, ')
          ..write('unreadCount: $unreadCount, ')
          ..write('isMuted: $isMuted, ')
          ..write('isArchived: $isArchived, ')
          ..write('centroidLatitude: $centroidLatitude, ')
          ..write('centroidLongitude: $centroidLongitude, ')
          ..write('channelRadiusMeters: $channelRadiusMeters, ')
          ..write('geohash: $geohash, ')
          ..write('creatorId: $creatorId, ')
          ..write('maxMessageAgeHours: $maxMessageAgeHours, ')
          ..write('isPublic: $isPublic, ')
          ..write('participantCount: $participantCount, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $MessagesTable extends Messages
    with TableInfo<$MessagesTable, MessageEntity> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $MessagesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _conversationIdMeta = const VerificationMeta(
    'conversationId',
  );
  @override
  late final GeneratedColumn<String> conversationId = GeneratedColumn<String>(
    'conversation_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES conversations (id)',
    ),
  );
  static const VerificationMeta _senderIdMeta = const VerificationMeta(
    'senderId',
  );
  @override
  late final GeneratedColumn<String> senderId = GeneratedColumn<String>(
    'sender_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _contentMeta = const VerificationMeta(
    'content',
  );
  @override
  late final GeneratedColumn<String> content = GeneratedColumn<String>(
    'content',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _typeMeta = const VerificationMeta('type');
  @override
  late final GeneratedColumn<String> type = GeneratedColumn<String>(
    'type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('text'),
  );
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
    'status',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('pending'),
  );
  static const VerificationMeta _transportMeta = const VerificationMeta(
    'transport',
  );
  @override
  late final GeneratedColumn<String> transport = GeneratedColumn<String>(
    'transport',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _timestampMeta = const VerificationMeta(
    'timestamp',
  );
  @override
  late final GeneratedColumn<DateTime> timestamp = GeneratedColumn<DateTime>(
    'timestamp',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _deliveredAtMeta = const VerificationMeta(
    'deliveredAt',
  );
  @override
  late final GeneratedColumn<DateTime> deliveredAt = GeneratedColumn<DateTime>(
    'delivered_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _readAtMeta = const VerificationMeta('readAt');
  @override
  late final GeneratedColumn<DateTime> readAt = GeneratedColumn<DateTime>(
    'read_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isFromMeMeta = const VerificationMeta(
    'isFromMe',
  );
  @override
  late final GeneratedColumn<bool> isFromMe = GeneratedColumn<bool>(
    'is_from_me',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_from_me" IN (0, 1))',
    ),
  );
  static const VerificationMeta _replyToIdMeta = const VerificationMeta(
    'replyToId',
  );
  @override
  late final GeneratedColumn<String> replyToId = GeneratedColumn<String>(
    'reply_to_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _metadataMeta = const VerificationMeta(
    'metadata',
  );
  @override
  late final GeneratedColumn<String> metadata = GeneratedColumn<String>(
    'metadata',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    conversationId,
    senderId,
    content,
    type,
    status,
    transport,
    timestamp,
    deliveredAt,
    readAt,
    isFromMe,
    replyToId,
    metadata,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'messages';
  @override
  VerificationContext validateIntegrity(
    Insertable<MessageEntity> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('conversation_id')) {
      context.handle(
        _conversationIdMeta,
        conversationId.isAcceptableOrUnknown(
          data['conversation_id']!,
          _conversationIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_conversationIdMeta);
    }
    if (data.containsKey('sender_id')) {
      context.handle(
        _senderIdMeta,
        senderId.isAcceptableOrUnknown(data['sender_id']!, _senderIdMeta),
      );
    } else if (isInserting) {
      context.missing(_senderIdMeta);
    }
    if (data.containsKey('content')) {
      context.handle(
        _contentMeta,
        content.isAcceptableOrUnknown(data['content']!, _contentMeta),
      );
    } else if (isInserting) {
      context.missing(_contentMeta);
    }
    if (data.containsKey('type')) {
      context.handle(
        _typeMeta,
        type.isAcceptableOrUnknown(data['type']!, _typeMeta),
      );
    }
    if (data.containsKey('status')) {
      context.handle(
        _statusMeta,
        status.isAcceptableOrUnknown(data['status']!, _statusMeta),
      );
    }
    if (data.containsKey('transport')) {
      context.handle(
        _transportMeta,
        transport.isAcceptableOrUnknown(data['transport']!, _transportMeta),
      );
    }
    if (data.containsKey('timestamp')) {
      context.handle(
        _timestampMeta,
        timestamp.isAcceptableOrUnknown(data['timestamp']!, _timestampMeta),
      );
    } else if (isInserting) {
      context.missing(_timestampMeta);
    }
    if (data.containsKey('delivered_at')) {
      context.handle(
        _deliveredAtMeta,
        deliveredAt.isAcceptableOrUnknown(
          data['delivered_at']!,
          _deliveredAtMeta,
        ),
      );
    }
    if (data.containsKey('read_at')) {
      context.handle(
        _readAtMeta,
        readAt.isAcceptableOrUnknown(data['read_at']!, _readAtMeta),
      );
    }
    if (data.containsKey('is_from_me')) {
      context.handle(
        _isFromMeMeta,
        isFromMe.isAcceptableOrUnknown(data['is_from_me']!, _isFromMeMeta),
      );
    } else if (isInserting) {
      context.missing(_isFromMeMeta);
    }
    if (data.containsKey('reply_to_id')) {
      context.handle(
        _replyToIdMeta,
        replyToId.isAcceptableOrUnknown(data['reply_to_id']!, _replyToIdMeta),
      );
    }
    if (data.containsKey('metadata')) {
      context.handle(
        _metadataMeta,
        metadata.isAcceptableOrUnknown(data['metadata']!, _metadataMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  MessageEntity map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return MessageEntity(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      conversationId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}conversation_id'],
      )!,
      senderId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sender_id'],
      )!,
      content: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}content'],
      )!,
      type: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}type'],
      )!,
      status: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}status'],
      )!,
      transport: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}transport'],
      ),
      timestamp: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}timestamp'],
      )!,
      deliveredAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}delivered_at'],
      ),
      readAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}read_at'],
      ),
      isFromMe: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_from_me'],
      )!,
      replyToId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}reply_to_id'],
      ),
      metadata: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}metadata'],
      ),
    );
  }

  @override
  $MessagesTable createAlias(String alias) {
    return $MessagesTable(attachedDatabase, alias);
  }
}

class MessageEntity extends DataClass implements Insertable<MessageEntity> {
  /// Unique message ID (SHA256 hash of content + timestamp + sender)
  final String id;

  /// Conversation this message belongs to
  final String conversationId;

  /// Sender ID (contact ID)
  final String senderId;

  /// Message content (encrypted for storage)
  final String content;

  /// Message type (text, image, voice, file)
  final String type;

  /// Message status (pending, sent, delivered, read, failed)
  final String status;

  /// Transport used (cloud, mesh, bridge)
  final String? transport;

  /// When the message was created
  final DateTime timestamp;

  /// When the message was delivered
  final DateTime? deliveredAt;

  /// When the message was read
  final DateTime? readAt;

  /// Is this message from me
  final bool isFromMe;

  /// Reply to message ID (for threading)
  final String? replyToId;

  /// Metadata JSON (for media, reactions, etc.)
  final String? metadata;
  const MessageEntity({
    required this.id,
    required this.conversationId,
    required this.senderId,
    required this.content,
    required this.type,
    required this.status,
    this.transport,
    required this.timestamp,
    this.deliveredAt,
    this.readAt,
    required this.isFromMe,
    this.replyToId,
    this.metadata,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['conversation_id'] = Variable<String>(conversationId);
    map['sender_id'] = Variable<String>(senderId);
    map['content'] = Variable<String>(content);
    map['type'] = Variable<String>(type);
    map['status'] = Variable<String>(status);
    if (!nullToAbsent || transport != null) {
      map['transport'] = Variable<String>(transport);
    }
    map['timestamp'] = Variable<DateTime>(timestamp);
    if (!nullToAbsent || deliveredAt != null) {
      map['delivered_at'] = Variable<DateTime>(deliveredAt);
    }
    if (!nullToAbsent || readAt != null) {
      map['read_at'] = Variable<DateTime>(readAt);
    }
    map['is_from_me'] = Variable<bool>(isFromMe);
    if (!nullToAbsent || replyToId != null) {
      map['reply_to_id'] = Variable<String>(replyToId);
    }
    if (!nullToAbsent || metadata != null) {
      map['metadata'] = Variable<String>(metadata);
    }
    return map;
  }

  MessagesCompanion toCompanion(bool nullToAbsent) {
    return MessagesCompanion(
      id: Value(id),
      conversationId: Value(conversationId),
      senderId: Value(senderId),
      content: Value(content),
      type: Value(type),
      status: Value(status),
      transport: transport == null && nullToAbsent
          ? const Value.absent()
          : Value(transport),
      timestamp: Value(timestamp),
      deliveredAt: deliveredAt == null && nullToAbsent
          ? const Value.absent()
          : Value(deliveredAt),
      readAt: readAt == null && nullToAbsent
          ? const Value.absent()
          : Value(readAt),
      isFromMe: Value(isFromMe),
      replyToId: replyToId == null && nullToAbsent
          ? const Value.absent()
          : Value(replyToId),
      metadata: metadata == null && nullToAbsent
          ? const Value.absent()
          : Value(metadata),
    );
  }

  factory MessageEntity.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return MessageEntity(
      id: serializer.fromJson<String>(json['id']),
      conversationId: serializer.fromJson<String>(json['conversationId']),
      senderId: serializer.fromJson<String>(json['senderId']),
      content: serializer.fromJson<String>(json['content']),
      type: serializer.fromJson<String>(json['type']),
      status: serializer.fromJson<String>(json['status']),
      transport: serializer.fromJson<String?>(json['transport']),
      timestamp: serializer.fromJson<DateTime>(json['timestamp']),
      deliveredAt: serializer.fromJson<DateTime?>(json['deliveredAt']),
      readAt: serializer.fromJson<DateTime?>(json['readAt']),
      isFromMe: serializer.fromJson<bool>(json['isFromMe']),
      replyToId: serializer.fromJson<String?>(json['replyToId']),
      metadata: serializer.fromJson<String?>(json['metadata']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'conversationId': serializer.toJson<String>(conversationId),
      'senderId': serializer.toJson<String>(senderId),
      'content': serializer.toJson<String>(content),
      'type': serializer.toJson<String>(type),
      'status': serializer.toJson<String>(status),
      'transport': serializer.toJson<String?>(transport),
      'timestamp': serializer.toJson<DateTime>(timestamp),
      'deliveredAt': serializer.toJson<DateTime?>(deliveredAt),
      'readAt': serializer.toJson<DateTime?>(readAt),
      'isFromMe': serializer.toJson<bool>(isFromMe),
      'replyToId': serializer.toJson<String?>(replyToId),
      'metadata': serializer.toJson<String?>(metadata),
    };
  }

  MessageEntity copyWith({
    String? id,
    String? conversationId,
    String? senderId,
    String? content,
    String? type,
    String? status,
    Value<String?> transport = const Value.absent(),
    DateTime? timestamp,
    Value<DateTime?> deliveredAt = const Value.absent(),
    Value<DateTime?> readAt = const Value.absent(),
    bool? isFromMe,
    Value<String?> replyToId = const Value.absent(),
    Value<String?> metadata = const Value.absent(),
  }) => MessageEntity(
    id: id ?? this.id,
    conversationId: conversationId ?? this.conversationId,
    senderId: senderId ?? this.senderId,
    content: content ?? this.content,
    type: type ?? this.type,
    status: status ?? this.status,
    transport: transport.present ? transport.value : this.transport,
    timestamp: timestamp ?? this.timestamp,
    deliveredAt: deliveredAt.present ? deliveredAt.value : this.deliveredAt,
    readAt: readAt.present ? readAt.value : this.readAt,
    isFromMe: isFromMe ?? this.isFromMe,
    replyToId: replyToId.present ? replyToId.value : this.replyToId,
    metadata: metadata.present ? metadata.value : this.metadata,
  );
  MessageEntity copyWithCompanion(MessagesCompanion data) {
    return MessageEntity(
      id: data.id.present ? data.id.value : this.id,
      conversationId: data.conversationId.present
          ? data.conversationId.value
          : this.conversationId,
      senderId: data.senderId.present ? data.senderId.value : this.senderId,
      content: data.content.present ? data.content.value : this.content,
      type: data.type.present ? data.type.value : this.type,
      status: data.status.present ? data.status.value : this.status,
      transport: data.transport.present ? data.transport.value : this.transport,
      timestamp: data.timestamp.present ? data.timestamp.value : this.timestamp,
      deliveredAt: data.deliveredAt.present
          ? data.deliveredAt.value
          : this.deliveredAt,
      readAt: data.readAt.present ? data.readAt.value : this.readAt,
      isFromMe: data.isFromMe.present ? data.isFromMe.value : this.isFromMe,
      replyToId: data.replyToId.present ? data.replyToId.value : this.replyToId,
      metadata: data.metadata.present ? data.metadata.value : this.metadata,
    );
  }

  @override
  String toString() {
    return (StringBuffer('MessageEntity(')
          ..write('id: $id, ')
          ..write('conversationId: $conversationId, ')
          ..write('senderId: $senderId, ')
          ..write('content: $content, ')
          ..write('type: $type, ')
          ..write('status: $status, ')
          ..write('transport: $transport, ')
          ..write('timestamp: $timestamp, ')
          ..write('deliveredAt: $deliveredAt, ')
          ..write('readAt: $readAt, ')
          ..write('isFromMe: $isFromMe, ')
          ..write('replyToId: $replyToId, ')
          ..write('metadata: $metadata')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    conversationId,
    senderId,
    content,
    type,
    status,
    transport,
    timestamp,
    deliveredAt,
    readAt,
    isFromMe,
    replyToId,
    metadata,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is MessageEntity &&
          other.id == this.id &&
          other.conversationId == this.conversationId &&
          other.senderId == this.senderId &&
          other.content == this.content &&
          other.type == this.type &&
          other.status == this.status &&
          other.transport == this.transport &&
          other.timestamp == this.timestamp &&
          other.deliveredAt == this.deliveredAt &&
          other.readAt == this.readAt &&
          other.isFromMe == this.isFromMe &&
          other.replyToId == this.replyToId &&
          other.metadata == this.metadata);
}

class MessagesCompanion extends UpdateCompanion<MessageEntity> {
  final Value<String> id;
  final Value<String> conversationId;
  final Value<String> senderId;
  final Value<String> content;
  final Value<String> type;
  final Value<String> status;
  final Value<String?> transport;
  final Value<DateTime> timestamp;
  final Value<DateTime?> deliveredAt;
  final Value<DateTime?> readAt;
  final Value<bool> isFromMe;
  final Value<String?> replyToId;
  final Value<String?> metadata;
  final Value<int> rowid;
  const MessagesCompanion({
    this.id = const Value.absent(),
    this.conversationId = const Value.absent(),
    this.senderId = const Value.absent(),
    this.content = const Value.absent(),
    this.type = const Value.absent(),
    this.status = const Value.absent(),
    this.transport = const Value.absent(),
    this.timestamp = const Value.absent(),
    this.deliveredAt = const Value.absent(),
    this.readAt = const Value.absent(),
    this.isFromMe = const Value.absent(),
    this.replyToId = const Value.absent(),
    this.metadata = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  MessagesCompanion.insert({
    required String id,
    required String conversationId,
    required String senderId,
    required String content,
    this.type = const Value.absent(),
    this.status = const Value.absent(),
    this.transport = const Value.absent(),
    required DateTime timestamp,
    this.deliveredAt = const Value.absent(),
    this.readAt = const Value.absent(),
    required bool isFromMe,
    this.replyToId = const Value.absent(),
    this.metadata = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       conversationId = Value(conversationId),
       senderId = Value(senderId),
       content = Value(content),
       timestamp = Value(timestamp),
       isFromMe = Value(isFromMe);
  static Insertable<MessageEntity> custom({
    Expression<String>? id,
    Expression<String>? conversationId,
    Expression<String>? senderId,
    Expression<String>? content,
    Expression<String>? type,
    Expression<String>? status,
    Expression<String>? transport,
    Expression<DateTime>? timestamp,
    Expression<DateTime>? deliveredAt,
    Expression<DateTime>? readAt,
    Expression<bool>? isFromMe,
    Expression<String>? replyToId,
    Expression<String>? metadata,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (conversationId != null) 'conversation_id': conversationId,
      if (senderId != null) 'sender_id': senderId,
      if (content != null) 'content': content,
      if (type != null) 'type': type,
      if (status != null) 'status': status,
      if (transport != null) 'transport': transport,
      if (timestamp != null) 'timestamp': timestamp,
      if (deliveredAt != null) 'delivered_at': deliveredAt,
      if (readAt != null) 'read_at': readAt,
      if (isFromMe != null) 'is_from_me': isFromMe,
      if (replyToId != null) 'reply_to_id': replyToId,
      if (metadata != null) 'metadata': metadata,
      if (rowid != null) 'rowid': rowid,
    });
  }

  MessagesCompanion copyWith({
    Value<String>? id,
    Value<String>? conversationId,
    Value<String>? senderId,
    Value<String>? content,
    Value<String>? type,
    Value<String>? status,
    Value<String?>? transport,
    Value<DateTime>? timestamp,
    Value<DateTime?>? deliveredAt,
    Value<DateTime?>? readAt,
    Value<bool>? isFromMe,
    Value<String?>? replyToId,
    Value<String?>? metadata,
    Value<int>? rowid,
  }) {
    return MessagesCompanion(
      id: id ?? this.id,
      conversationId: conversationId ?? this.conversationId,
      senderId: senderId ?? this.senderId,
      content: content ?? this.content,
      type: type ?? this.type,
      status: status ?? this.status,
      transport: transport ?? this.transport,
      timestamp: timestamp ?? this.timestamp,
      deliveredAt: deliveredAt ?? this.deliveredAt,
      readAt: readAt ?? this.readAt,
      isFromMe: isFromMe ?? this.isFromMe,
      replyToId: replyToId ?? this.replyToId,
      metadata: metadata ?? this.metadata,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (conversationId.present) {
      map['conversation_id'] = Variable<String>(conversationId.value);
    }
    if (senderId.present) {
      map['sender_id'] = Variable<String>(senderId.value);
    }
    if (content.present) {
      map['content'] = Variable<String>(content.value);
    }
    if (type.present) {
      map['type'] = Variable<String>(type.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (transport.present) {
      map['transport'] = Variable<String>(transport.value);
    }
    if (timestamp.present) {
      map['timestamp'] = Variable<DateTime>(timestamp.value);
    }
    if (deliveredAt.present) {
      map['delivered_at'] = Variable<DateTime>(deliveredAt.value);
    }
    if (readAt.present) {
      map['read_at'] = Variable<DateTime>(readAt.value);
    }
    if (isFromMe.present) {
      map['is_from_me'] = Variable<bool>(isFromMe.value);
    }
    if (replyToId.present) {
      map['reply_to_id'] = Variable<String>(replyToId.value);
    }
    if (metadata.present) {
      map['metadata'] = Variable<String>(metadata.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('MessagesCompanion(')
          ..write('id: $id, ')
          ..write('conversationId: $conversationId, ')
          ..write('senderId: $senderId, ')
          ..write('content: $content, ')
          ..write('type: $type, ')
          ..write('status: $status, ')
          ..write('transport: $transport, ')
          ..write('timestamp: $timestamp, ')
          ..write('deliveredAt: $deliveredAt, ')
          ..write('readAt: $readAt, ')
          ..write('isFromMe: $isFromMe, ')
          ..write('replyToId: $replyToId, ')
          ..write('metadata: $metadata, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $GroupMembersTable extends GroupMembers
    with TableInfo<$GroupMembersTable, GroupMemberEntity> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $GroupMembersTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _conversationIdMeta = const VerificationMeta(
    'conversationId',
  );
  @override
  late final GeneratedColumn<String> conversationId = GeneratedColumn<String>(
    'conversation_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES conversations (id)',
    ),
  );
  static const VerificationMeta _contactIdMeta = const VerificationMeta(
    'contactId',
  );
  @override
  late final GeneratedColumn<String> contactId = GeneratedColumn<String>(
    'contact_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES contacts (id)',
    ),
  );
  static const VerificationMeta _roleMeta = const VerificationMeta('role');
  @override
  late final GeneratedColumn<String> role = GeneratedColumn<String>(
    'role',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('member'),
  );
  static const VerificationMeta _joinedAtMeta = const VerificationMeta(
    'joinedAt',
  );
  @override
  late final GeneratedColumn<DateTime> joinedAt = GeneratedColumn<DateTime>(
    'joined_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    conversationId,
    contactId,
    role,
    joinedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'group_members';
  @override
  VerificationContext validateIntegrity(
    Insertable<GroupMemberEntity> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('conversation_id')) {
      context.handle(
        _conversationIdMeta,
        conversationId.isAcceptableOrUnknown(
          data['conversation_id']!,
          _conversationIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_conversationIdMeta);
    }
    if (data.containsKey('contact_id')) {
      context.handle(
        _contactIdMeta,
        contactId.isAcceptableOrUnknown(data['contact_id']!, _contactIdMeta),
      );
    } else if (isInserting) {
      context.missing(_contactIdMeta);
    }
    if (data.containsKey('role')) {
      context.handle(
        _roleMeta,
        role.isAcceptableOrUnknown(data['role']!, _roleMeta),
      );
    }
    if (data.containsKey('joined_at')) {
      context.handle(
        _joinedAtMeta,
        joinedAt.isAcceptableOrUnknown(data['joined_at']!, _joinedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_joinedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
    {conversationId, contactId},
  ];
  @override
  GroupMemberEntity map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return GroupMemberEntity(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      conversationId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}conversation_id'],
      )!,
      contactId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}contact_id'],
      )!,
      role: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}role'],
      )!,
      joinedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}joined_at'],
      )!,
    );
  }

  @override
  $GroupMembersTable createAlias(String alias) {
    return $GroupMembersTable(attachedDatabase, alias);
  }
}

class GroupMemberEntity extends DataClass
    implements Insertable<GroupMemberEntity> {
  /// Auto-incrementing ID
  final int id;

  /// Conversation (group) ID
  final String conversationId;

  /// Contact ID
  final String contactId;

  /// Member role (owner, admin, member)
  final String role;

  /// When the member joined
  final DateTime joinedAt;
  const GroupMemberEntity({
    required this.id,
    required this.conversationId,
    required this.contactId,
    required this.role,
    required this.joinedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['conversation_id'] = Variable<String>(conversationId);
    map['contact_id'] = Variable<String>(contactId);
    map['role'] = Variable<String>(role);
    map['joined_at'] = Variable<DateTime>(joinedAt);
    return map;
  }

  GroupMembersCompanion toCompanion(bool nullToAbsent) {
    return GroupMembersCompanion(
      id: Value(id),
      conversationId: Value(conversationId),
      contactId: Value(contactId),
      role: Value(role),
      joinedAt: Value(joinedAt),
    );
  }

  factory GroupMemberEntity.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return GroupMemberEntity(
      id: serializer.fromJson<int>(json['id']),
      conversationId: serializer.fromJson<String>(json['conversationId']),
      contactId: serializer.fromJson<String>(json['contactId']),
      role: serializer.fromJson<String>(json['role']),
      joinedAt: serializer.fromJson<DateTime>(json['joinedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'conversationId': serializer.toJson<String>(conversationId),
      'contactId': serializer.toJson<String>(contactId),
      'role': serializer.toJson<String>(role),
      'joinedAt': serializer.toJson<DateTime>(joinedAt),
    };
  }

  GroupMemberEntity copyWith({
    int? id,
    String? conversationId,
    String? contactId,
    String? role,
    DateTime? joinedAt,
  }) => GroupMemberEntity(
    id: id ?? this.id,
    conversationId: conversationId ?? this.conversationId,
    contactId: contactId ?? this.contactId,
    role: role ?? this.role,
    joinedAt: joinedAt ?? this.joinedAt,
  );
  GroupMemberEntity copyWithCompanion(GroupMembersCompanion data) {
    return GroupMemberEntity(
      id: data.id.present ? data.id.value : this.id,
      conversationId: data.conversationId.present
          ? data.conversationId.value
          : this.conversationId,
      contactId: data.contactId.present ? data.contactId.value : this.contactId,
      role: data.role.present ? data.role.value : this.role,
      joinedAt: data.joinedAt.present ? data.joinedAt.value : this.joinedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('GroupMemberEntity(')
          ..write('id: $id, ')
          ..write('conversationId: $conversationId, ')
          ..write('contactId: $contactId, ')
          ..write('role: $role, ')
          ..write('joinedAt: $joinedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, conversationId, contactId, role, joinedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is GroupMemberEntity &&
          other.id == this.id &&
          other.conversationId == this.conversationId &&
          other.contactId == this.contactId &&
          other.role == this.role &&
          other.joinedAt == this.joinedAt);
}

class GroupMembersCompanion extends UpdateCompanion<GroupMemberEntity> {
  final Value<int> id;
  final Value<String> conversationId;
  final Value<String> contactId;
  final Value<String> role;
  final Value<DateTime> joinedAt;
  const GroupMembersCompanion({
    this.id = const Value.absent(),
    this.conversationId = const Value.absent(),
    this.contactId = const Value.absent(),
    this.role = const Value.absent(),
    this.joinedAt = const Value.absent(),
  });
  GroupMembersCompanion.insert({
    this.id = const Value.absent(),
    required String conversationId,
    required String contactId,
    this.role = const Value.absent(),
    required DateTime joinedAt,
  }) : conversationId = Value(conversationId),
       contactId = Value(contactId),
       joinedAt = Value(joinedAt);
  static Insertable<GroupMemberEntity> custom({
    Expression<int>? id,
    Expression<String>? conversationId,
    Expression<String>? contactId,
    Expression<String>? role,
    Expression<DateTime>? joinedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (conversationId != null) 'conversation_id': conversationId,
      if (contactId != null) 'contact_id': contactId,
      if (role != null) 'role': role,
      if (joinedAt != null) 'joined_at': joinedAt,
    });
  }

  GroupMembersCompanion copyWith({
    Value<int>? id,
    Value<String>? conversationId,
    Value<String>? contactId,
    Value<String>? role,
    Value<DateTime>? joinedAt,
  }) {
    return GroupMembersCompanion(
      id: id ?? this.id,
      conversationId: conversationId ?? this.conversationId,
      contactId: contactId ?? this.contactId,
      role: role ?? this.role,
      joinedAt: joinedAt ?? this.joinedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (conversationId.present) {
      map['conversation_id'] = Variable<String>(conversationId.value);
    }
    if (contactId.present) {
      map['contact_id'] = Variable<String>(contactId.value);
    }
    if (role.present) {
      map['role'] = Variable<String>(role.value);
    }
    if (joinedAt.present) {
      map['joined_at'] = Variable<DateTime>(joinedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('GroupMembersCompanion(')
          ..write('id: $id, ')
          ..write('conversationId: $conversationId, ')
          ..write('contactId: $contactId, ')
          ..write('role: $role, ')
          ..write('joinedAt: $joinedAt')
          ..write(')'))
        .toString();
  }
}

class $MeshPeersTable extends MeshPeers
    with TableInfo<$MeshPeersTable, MeshPeerEntity> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $MeshPeersTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _meshPeerIdMeta = const VerificationMeta(
    'meshPeerId',
  );
  @override
  late final GeneratedColumn<String> meshPeerId = GeneratedColumn<String>(
    'mesh_peer_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _publicKeyMeta = const VerificationMeta(
    'publicKey',
  );
  @override
  late final GeneratedColumn<String> publicKey = GeneratedColumn<String>(
    'public_key',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _exchangePublicKeyMeta = const VerificationMeta(
    'exchangePublicKey',
  );
  @override
  late final GeneratedColumn<String> exchangePublicKey =
      GeneratedColumn<String>(
        'exchange_public_key',
        aliasedName,
        false,
        type: DriftSqlType.string,
        requiredDuringInsert: true,
      );
  static const VerificationMeta _displayNameMeta = const VerificationMeta(
    'displayName',
  );
  @override
  late final GeneratedColumn<String> displayName = GeneratedColumn<String>(
    'display_name',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _rssiMeta = const VerificationMeta('rssi');
  @override
  late final GeneratedColumn<int> rssi = GeneratedColumn<int>(
    'rssi',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _connectionStateMeta = const VerificationMeta(
    'connectionState',
  );
  @override
  late final GeneratedColumn<String> connectionState = GeneratedColumn<String>(
    'connection_state',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('discovered'),
  );
  static const VerificationMeta _lastSeenMeta = const VerificationMeta(
    'lastSeen',
  );
  @override
  late final GeneratedColumn<DateTime> lastSeen = GeneratedColumn<DateTime>(
    'last_seen',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _firstSeenMeta = const VerificationMeta(
    'firstSeen',
  );
  @override
  late final GeneratedColumn<DateTime> firstSeen = GeneratedColumn<DateTime>(
    'first_seen',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _noiseSessionStateMeta = const VerificationMeta(
    'noiseSessionState',
  );
  @override
  late final GeneratedColumn<String> noiseSessionState =
      GeneratedColumn<String>(
        'noise_session_state',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _noiseTransportStateMeta =
      const VerificationMeta('noiseTransportState');
  @override
  late final GeneratedColumn<String> noiseTransportState =
      GeneratedColumn<String>(
        'noise_transport_state',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _isContactMeta = const VerificationMeta(
    'isContact',
  );
  @override
  late final GeneratedColumn<bool> isContact = GeneratedColumn<bool>(
    'is_contact',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_contact" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _contactIdMeta = const VerificationMeta(
    'contactId',
  );
  @override
  late final GeneratedColumn<String> contactId = GeneratedColumn<String>(
    'contact_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES contacts (id)',
    ),
  );
  @override
  List<GeneratedColumn> get $columns => [
    meshPeerId,
    publicKey,
    exchangePublicKey,
    displayName,
    rssi,
    connectionState,
    lastSeen,
    firstSeen,
    noiseSessionState,
    noiseTransportState,
    isContact,
    contactId,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'mesh_peers';
  @override
  VerificationContext validateIntegrity(
    Insertable<MeshPeerEntity> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('mesh_peer_id')) {
      context.handle(
        _meshPeerIdMeta,
        meshPeerId.isAcceptableOrUnknown(
          data['mesh_peer_id']!,
          _meshPeerIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_meshPeerIdMeta);
    }
    if (data.containsKey('public_key')) {
      context.handle(
        _publicKeyMeta,
        publicKey.isAcceptableOrUnknown(data['public_key']!, _publicKeyMeta),
      );
    } else if (isInserting) {
      context.missing(_publicKeyMeta);
    }
    if (data.containsKey('exchange_public_key')) {
      context.handle(
        _exchangePublicKeyMeta,
        exchangePublicKey.isAcceptableOrUnknown(
          data['exchange_public_key']!,
          _exchangePublicKeyMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_exchangePublicKeyMeta);
    }
    if (data.containsKey('display_name')) {
      context.handle(
        _displayNameMeta,
        displayName.isAcceptableOrUnknown(
          data['display_name']!,
          _displayNameMeta,
        ),
      );
    }
    if (data.containsKey('rssi')) {
      context.handle(
        _rssiMeta,
        rssi.isAcceptableOrUnknown(data['rssi']!, _rssiMeta),
      );
    } else if (isInserting) {
      context.missing(_rssiMeta);
    }
    if (data.containsKey('connection_state')) {
      context.handle(
        _connectionStateMeta,
        connectionState.isAcceptableOrUnknown(
          data['connection_state']!,
          _connectionStateMeta,
        ),
      );
    }
    if (data.containsKey('last_seen')) {
      context.handle(
        _lastSeenMeta,
        lastSeen.isAcceptableOrUnknown(data['last_seen']!, _lastSeenMeta),
      );
    } else if (isInserting) {
      context.missing(_lastSeenMeta);
    }
    if (data.containsKey('first_seen')) {
      context.handle(
        _firstSeenMeta,
        firstSeen.isAcceptableOrUnknown(data['first_seen']!, _firstSeenMeta),
      );
    } else if (isInserting) {
      context.missing(_firstSeenMeta);
    }
    if (data.containsKey('noise_session_state')) {
      context.handle(
        _noiseSessionStateMeta,
        noiseSessionState.isAcceptableOrUnknown(
          data['noise_session_state']!,
          _noiseSessionStateMeta,
        ),
      );
    }
    if (data.containsKey('noise_transport_state')) {
      context.handle(
        _noiseTransportStateMeta,
        noiseTransportState.isAcceptableOrUnknown(
          data['noise_transport_state']!,
          _noiseTransportStateMeta,
        ),
      );
    }
    if (data.containsKey('is_contact')) {
      context.handle(
        _isContactMeta,
        isContact.isAcceptableOrUnknown(data['is_contact']!, _isContactMeta),
      );
    }
    if (data.containsKey('contact_id')) {
      context.handle(
        _contactIdMeta,
        contactId.isAcceptableOrUnknown(data['contact_id']!, _contactIdMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {meshPeerId};
  @override
  MeshPeerEntity map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return MeshPeerEntity(
      meshPeerId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}mesh_peer_id'],
      )!,
      publicKey: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}public_key'],
      )!,
      exchangePublicKey: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}exchange_public_key'],
      )!,
      displayName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}display_name'],
      ),
      rssi: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}rssi'],
      )!,
      connectionState: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}connection_state'],
      )!,
      lastSeen: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_seen'],
      )!,
      firstSeen: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}first_seen'],
      )!,
      noiseSessionState: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}noise_session_state'],
      ),
      noiseTransportState: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}noise_transport_state'],
      ),
      isContact: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_contact'],
      )!,
      contactId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}contact_id'],
      ),
    );
  }

  @override
  $MeshPeersTable createAlias(String alias) {
    return $MeshPeersTable(attachedDatabase, alias);
  }
}

class MeshPeerEntity extends DataClass implements Insertable<MeshPeerEntity> {
  /// Mesh peer ID (8 bytes from SHA256 of Ed25519 public key, hex encoded)
  final String meshPeerId;

  /// Ed25519 public key (hex encoded, for verification)
  final String publicKey;

  /// X25519 public key for key exchange (hex encoded)
  final String exchangePublicKey;

  /// Display name (optional, from peer announcement)
  final String? displayName;

  /// RSSI (signal strength in dBm, updated on each scan)
  final int rssi;

  /// Connection state (discovered, connecting, connected, disconnected)
  final String connectionState;

  /// Last time we saw this peer in BLE scan
  final DateTime lastSeen;

  /// First discovered timestamp
  final DateTime firstSeen;

  /// Noise session state (null, handshake_init, handshake_resp, established)
  final String? noiseSessionState;

  /// Noise transport state (encrypted session keys, serialized as JSON)
  final String? noiseTransportState;

  /// Is this peer a contact we know?
  final bool isContact;

  /// Contact ID if this peer is a known contact
  final String? contactId;
  const MeshPeerEntity({
    required this.meshPeerId,
    required this.publicKey,
    required this.exchangePublicKey,
    this.displayName,
    required this.rssi,
    required this.connectionState,
    required this.lastSeen,
    required this.firstSeen,
    this.noiseSessionState,
    this.noiseTransportState,
    required this.isContact,
    this.contactId,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['mesh_peer_id'] = Variable<String>(meshPeerId);
    map['public_key'] = Variable<String>(publicKey);
    map['exchange_public_key'] = Variable<String>(exchangePublicKey);
    if (!nullToAbsent || displayName != null) {
      map['display_name'] = Variable<String>(displayName);
    }
    map['rssi'] = Variable<int>(rssi);
    map['connection_state'] = Variable<String>(connectionState);
    map['last_seen'] = Variable<DateTime>(lastSeen);
    map['first_seen'] = Variable<DateTime>(firstSeen);
    if (!nullToAbsent || noiseSessionState != null) {
      map['noise_session_state'] = Variable<String>(noiseSessionState);
    }
    if (!nullToAbsent || noiseTransportState != null) {
      map['noise_transport_state'] = Variable<String>(noiseTransportState);
    }
    map['is_contact'] = Variable<bool>(isContact);
    if (!nullToAbsent || contactId != null) {
      map['contact_id'] = Variable<String>(contactId);
    }
    return map;
  }

  MeshPeersCompanion toCompanion(bool nullToAbsent) {
    return MeshPeersCompanion(
      meshPeerId: Value(meshPeerId),
      publicKey: Value(publicKey),
      exchangePublicKey: Value(exchangePublicKey),
      displayName: displayName == null && nullToAbsent
          ? const Value.absent()
          : Value(displayName),
      rssi: Value(rssi),
      connectionState: Value(connectionState),
      lastSeen: Value(lastSeen),
      firstSeen: Value(firstSeen),
      noiseSessionState: noiseSessionState == null && nullToAbsent
          ? const Value.absent()
          : Value(noiseSessionState),
      noiseTransportState: noiseTransportState == null && nullToAbsent
          ? const Value.absent()
          : Value(noiseTransportState),
      isContact: Value(isContact),
      contactId: contactId == null && nullToAbsent
          ? const Value.absent()
          : Value(contactId),
    );
  }

  factory MeshPeerEntity.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return MeshPeerEntity(
      meshPeerId: serializer.fromJson<String>(json['meshPeerId']),
      publicKey: serializer.fromJson<String>(json['publicKey']),
      exchangePublicKey: serializer.fromJson<String>(json['exchangePublicKey']),
      displayName: serializer.fromJson<String?>(json['displayName']),
      rssi: serializer.fromJson<int>(json['rssi']),
      connectionState: serializer.fromJson<String>(json['connectionState']),
      lastSeen: serializer.fromJson<DateTime>(json['lastSeen']),
      firstSeen: serializer.fromJson<DateTime>(json['firstSeen']),
      noiseSessionState: serializer.fromJson<String?>(
        json['noiseSessionState'],
      ),
      noiseTransportState: serializer.fromJson<String?>(
        json['noiseTransportState'],
      ),
      isContact: serializer.fromJson<bool>(json['isContact']),
      contactId: serializer.fromJson<String?>(json['contactId']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'meshPeerId': serializer.toJson<String>(meshPeerId),
      'publicKey': serializer.toJson<String>(publicKey),
      'exchangePublicKey': serializer.toJson<String>(exchangePublicKey),
      'displayName': serializer.toJson<String?>(displayName),
      'rssi': serializer.toJson<int>(rssi),
      'connectionState': serializer.toJson<String>(connectionState),
      'lastSeen': serializer.toJson<DateTime>(lastSeen),
      'firstSeen': serializer.toJson<DateTime>(firstSeen),
      'noiseSessionState': serializer.toJson<String?>(noiseSessionState),
      'noiseTransportState': serializer.toJson<String?>(noiseTransportState),
      'isContact': serializer.toJson<bool>(isContact),
      'contactId': serializer.toJson<String?>(contactId),
    };
  }

  MeshPeerEntity copyWith({
    String? meshPeerId,
    String? publicKey,
    String? exchangePublicKey,
    Value<String?> displayName = const Value.absent(),
    int? rssi,
    String? connectionState,
    DateTime? lastSeen,
    DateTime? firstSeen,
    Value<String?> noiseSessionState = const Value.absent(),
    Value<String?> noiseTransportState = const Value.absent(),
    bool? isContact,
    Value<String?> contactId = const Value.absent(),
  }) => MeshPeerEntity(
    meshPeerId: meshPeerId ?? this.meshPeerId,
    publicKey: publicKey ?? this.publicKey,
    exchangePublicKey: exchangePublicKey ?? this.exchangePublicKey,
    displayName: displayName.present ? displayName.value : this.displayName,
    rssi: rssi ?? this.rssi,
    connectionState: connectionState ?? this.connectionState,
    lastSeen: lastSeen ?? this.lastSeen,
    firstSeen: firstSeen ?? this.firstSeen,
    noiseSessionState: noiseSessionState.present
        ? noiseSessionState.value
        : this.noiseSessionState,
    noiseTransportState: noiseTransportState.present
        ? noiseTransportState.value
        : this.noiseTransportState,
    isContact: isContact ?? this.isContact,
    contactId: contactId.present ? contactId.value : this.contactId,
  );
  MeshPeerEntity copyWithCompanion(MeshPeersCompanion data) {
    return MeshPeerEntity(
      meshPeerId: data.meshPeerId.present
          ? data.meshPeerId.value
          : this.meshPeerId,
      publicKey: data.publicKey.present ? data.publicKey.value : this.publicKey,
      exchangePublicKey: data.exchangePublicKey.present
          ? data.exchangePublicKey.value
          : this.exchangePublicKey,
      displayName: data.displayName.present
          ? data.displayName.value
          : this.displayName,
      rssi: data.rssi.present ? data.rssi.value : this.rssi,
      connectionState: data.connectionState.present
          ? data.connectionState.value
          : this.connectionState,
      lastSeen: data.lastSeen.present ? data.lastSeen.value : this.lastSeen,
      firstSeen: data.firstSeen.present ? data.firstSeen.value : this.firstSeen,
      noiseSessionState: data.noiseSessionState.present
          ? data.noiseSessionState.value
          : this.noiseSessionState,
      noiseTransportState: data.noiseTransportState.present
          ? data.noiseTransportState.value
          : this.noiseTransportState,
      isContact: data.isContact.present ? data.isContact.value : this.isContact,
      contactId: data.contactId.present ? data.contactId.value : this.contactId,
    );
  }

  @override
  String toString() {
    return (StringBuffer('MeshPeerEntity(')
          ..write('meshPeerId: $meshPeerId, ')
          ..write('publicKey: $publicKey, ')
          ..write('exchangePublicKey: $exchangePublicKey, ')
          ..write('displayName: $displayName, ')
          ..write('rssi: $rssi, ')
          ..write('connectionState: $connectionState, ')
          ..write('lastSeen: $lastSeen, ')
          ..write('firstSeen: $firstSeen, ')
          ..write('noiseSessionState: $noiseSessionState, ')
          ..write('noiseTransportState: $noiseTransportState, ')
          ..write('isContact: $isContact, ')
          ..write('contactId: $contactId')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    meshPeerId,
    publicKey,
    exchangePublicKey,
    displayName,
    rssi,
    connectionState,
    lastSeen,
    firstSeen,
    noiseSessionState,
    noiseTransportState,
    isContact,
    contactId,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is MeshPeerEntity &&
          other.meshPeerId == this.meshPeerId &&
          other.publicKey == this.publicKey &&
          other.exchangePublicKey == this.exchangePublicKey &&
          other.displayName == this.displayName &&
          other.rssi == this.rssi &&
          other.connectionState == this.connectionState &&
          other.lastSeen == this.lastSeen &&
          other.firstSeen == this.firstSeen &&
          other.noiseSessionState == this.noiseSessionState &&
          other.noiseTransportState == this.noiseTransportState &&
          other.isContact == this.isContact &&
          other.contactId == this.contactId);
}

class MeshPeersCompanion extends UpdateCompanion<MeshPeerEntity> {
  final Value<String> meshPeerId;
  final Value<String> publicKey;
  final Value<String> exchangePublicKey;
  final Value<String?> displayName;
  final Value<int> rssi;
  final Value<String> connectionState;
  final Value<DateTime> lastSeen;
  final Value<DateTime> firstSeen;
  final Value<String?> noiseSessionState;
  final Value<String?> noiseTransportState;
  final Value<bool> isContact;
  final Value<String?> contactId;
  final Value<int> rowid;
  const MeshPeersCompanion({
    this.meshPeerId = const Value.absent(),
    this.publicKey = const Value.absent(),
    this.exchangePublicKey = const Value.absent(),
    this.displayName = const Value.absent(),
    this.rssi = const Value.absent(),
    this.connectionState = const Value.absent(),
    this.lastSeen = const Value.absent(),
    this.firstSeen = const Value.absent(),
    this.noiseSessionState = const Value.absent(),
    this.noiseTransportState = const Value.absent(),
    this.isContact = const Value.absent(),
    this.contactId = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  MeshPeersCompanion.insert({
    required String meshPeerId,
    required String publicKey,
    required String exchangePublicKey,
    this.displayName = const Value.absent(),
    required int rssi,
    this.connectionState = const Value.absent(),
    required DateTime lastSeen,
    required DateTime firstSeen,
    this.noiseSessionState = const Value.absent(),
    this.noiseTransportState = const Value.absent(),
    this.isContact = const Value.absent(),
    this.contactId = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : meshPeerId = Value(meshPeerId),
       publicKey = Value(publicKey),
       exchangePublicKey = Value(exchangePublicKey),
       rssi = Value(rssi),
       lastSeen = Value(lastSeen),
       firstSeen = Value(firstSeen);
  static Insertable<MeshPeerEntity> custom({
    Expression<String>? meshPeerId,
    Expression<String>? publicKey,
    Expression<String>? exchangePublicKey,
    Expression<String>? displayName,
    Expression<int>? rssi,
    Expression<String>? connectionState,
    Expression<DateTime>? lastSeen,
    Expression<DateTime>? firstSeen,
    Expression<String>? noiseSessionState,
    Expression<String>? noiseTransportState,
    Expression<bool>? isContact,
    Expression<String>? contactId,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (meshPeerId != null) 'mesh_peer_id': meshPeerId,
      if (publicKey != null) 'public_key': publicKey,
      if (exchangePublicKey != null) 'exchange_public_key': exchangePublicKey,
      if (displayName != null) 'display_name': displayName,
      if (rssi != null) 'rssi': rssi,
      if (connectionState != null) 'connection_state': connectionState,
      if (lastSeen != null) 'last_seen': lastSeen,
      if (firstSeen != null) 'first_seen': firstSeen,
      if (noiseSessionState != null) 'noise_session_state': noiseSessionState,
      if (noiseTransportState != null)
        'noise_transport_state': noiseTransportState,
      if (isContact != null) 'is_contact': isContact,
      if (contactId != null) 'contact_id': contactId,
      if (rowid != null) 'rowid': rowid,
    });
  }

  MeshPeersCompanion copyWith({
    Value<String>? meshPeerId,
    Value<String>? publicKey,
    Value<String>? exchangePublicKey,
    Value<String?>? displayName,
    Value<int>? rssi,
    Value<String>? connectionState,
    Value<DateTime>? lastSeen,
    Value<DateTime>? firstSeen,
    Value<String?>? noiseSessionState,
    Value<String?>? noiseTransportState,
    Value<bool>? isContact,
    Value<String?>? contactId,
    Value<int>? rowid,
  }) {
    return MeshPeersCompanion(
      meshPeerId: meshPeerId ?? this.meshPeerId,
      publicKey: publicKey ?? this.publicKey,
      exchangePublicKey: exchangePublicKey ?? this.exchangePublicKey,
      displayName: displayName ?? this.displayName,
      rssi: rssi ?? this.rssi,
      connectionState: connectionState ?? this.connectionState,
      lastSeen: lastSeen ?? this.lastSeen,
      firstSeen: firstSeen ?? this.firstSeen,
      noiseSessionState: noiseSessionState ?? this.noiseSessionState,
      noiseTransportState: noiseTransportState ?? this.noiseTransportState,
      isContact: isContact ?? this.isContact,
      contactId: contactId ?? this.contactId,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (meshPeerId.present) {
      map['mesh_peer_id'] = Variable<String>(meshPeerId.value);
    }
    if (publicKey.present) {
      map['public_key'] = Variable<String>(publicKey.value);
    }
    if (exchangePublicKey.present) {
      map['exchange_public_key'] = Variable<String>(exchangePublicKey.value);
    }
    if (displayName.present) {
      map['display_name'] = Variable<String>(displayName.value);
    }
    if (rssi.present) {
      map['rssi'] = Variable<int>(rssi.value);
    }
    if (connectionState.present) {
      map['connection_state'] = Variable<String>(connectionState.value);
    }
    if (lastSeen.present) {
      map['last_seen'] = Variable<DateTime>(lastSeen.value);
    }
    if (firstSeen.present) {
      map['first_seen'] = Variable<DateTime>(firstSeen.value);
    }
    if (noiseSessionState.present) {
      map['noise_session_state'] = Variable<String>(noiseSessionState.value);
    }
    if (noiseTransportState.present) {
      map['noise_transport_state'] = Variable<String>(
        noiseTransportState.value,
      );
    }
    if (isContact.present) {
      map['is_contact'] = Variable<bool>(isContact.value);
    }
    if (contactId.present) {
      map['contact_id'] = Variable<String>(contactId.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('MeshPeersCompanion(')
          ..write('meshPeerId: $meshPeerId, ')
          ..write('publicKey: $publicKey, ')
          ..write('exchangePublicKey: $exchangePublicKey, ')
          ..write('displayName: $displayName, ')
          ..write('rssi: $rssi, ')
          ..write('connectionState: $connectionState, ')
          ..write('lastSeen: $lastSeen, ')
          ..write('firstSeen: $firstSeen, ')
          ..write('noiseSessionState: $noiseSessionState, ')
          ..write('noiseTransportState: $noiseTransportState, ')
          ..write('isContact: $isContact, ')
          ..write('contactId: $contactId, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $MeshRoutesTable extends MeshRoutes
    with TableInfo<$MeshRoutesTable, MeshRouteEntity> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $MeshRoutesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _destinationPeerIdMeta = const VerificationMeta(
    'destinationPeerId',
  );
  @override
  late final GeneratedColumn<String> destinationPeerId =
      GeneratedColumn<String>(
        'destination_peer_id',
        aliasedName,
        false,
        type: DriftSqlType.string,
        requiredDuringInsert: true,
      );
  static const VerificationMeta _nextHopPeerIdMeta = const VerificationMeta(
    'nextHopPeerId',
  );
  @override
  late final GeneratedColumn<String> nextHopPeerId = GeneratedColumn<String>(
    'next_hop_peer_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _hopCountMeta = const VerificationMeta(
    'hopCount',
  );
  @override
  late final GeneratedColumn<int> hopCount = GeneratedColumn<int>(
    'hop_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _qualityScoreMeta = const VerificationMeta(
    'qualityScore',
  );
  @override
  late final GeneratedColumn<double> qualityScore = GeneratedColumn<double>(
    'quality_score',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(1.0),
  );
  static const VerificationMeta _lastUsedMeta = const VerificationMeta(
    'lastUsed',
  );
  @override
  late final GeneratedColumn<DateTime> lastUsed = GeneratedColumn<DateTime>(
    'last_used',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _discoveredAtMeta = const VerificationMeta(
    'discoveredAt',
  );
  @override
  late final GeneratedColumn<DateTime> discoveredAt = GeneratedColumn<DateTime>(
    'discovered_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _expiresAtMeta = const VerificationMeta(
    'expiresAt',
  );
  @override
  late final GeneratedColumn<DateTime> expiresAt = GeneratedColumn<DateTime>(
    'expires_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    destinationPeerId,
    nextHopPeerId,
    hopCount,
    qualityScore,
    lastUsed,
    discoveredAt,
    expiresAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'mesh_routes';
  @override
  VerificationContext validateIntegrity(
    Insertable<MeshRouteEntity> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('destination_peer_id')) {
      context.handle(
        _destinationPeerIdMeta,
        destinationPeerId.isAcceptableOrUnknown(
          data['destination_peer_id']!,
          _destinationPeerIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_destinationPeerIdMeta);
    }
    if (data.containsKey('next_hop_peer_id')) {
      context.handle(
        _nextHopPeerIdMeta,
        nextHopPeerId.isAcceptableOrUnknown(
          data['next_hop_peer_id']!,
          _nextHopPeerIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_nextHopPeerIdMeta);
    }
    if (data.containsKey('hop_count')) {
      context.handle(
        _hopCountMeta,
        hopCount.isAcceptableOrUnknown(data['hop_count']!, _hopCountMeta),
      );
    } else if (isInserting) {
      context.missing(_hopCountMeta);
    }
    if (data.containsKey('quality_score')) {
      context.handle(
        _qualityScoreMeta,
        qualityScore.isAcceptableOrUnknown(
          data['quality_score']!,
          _qualityScoreMeta,
        ),
      );
    }
    if (data.containsKey('last_used')) {
      context.handle(
        _lastUsedMeta,
        lastUsed.isAcceptableOrUnknown(data['last_used']!, _lastUsedMeta),
      );
    } else if (isInserting) {
      context.missing(_lastUsedMeta);
    }
    if (data.containsKey('discovered_at')) {
      context.handle(
        _discoveredAtMeta,
        discoveredAt.isAcceptableOrUnknown(
          data['discovered_at']!,
          _discoveredAtMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_discoveredAtMeta);
    }
    if (data.containsKey('expires_at')) {
      context.handle(
        _expiresAtMeta,
        expiresAt.isAcceptableOrUnknown(data['expires_at']!, _expiresAtMeta),
      );
    } else if (isInserting) {
      context.missing(_expiresAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  MeshRouteEntity map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return MeshRouteEntity(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      destinationPeerId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}destination_peer_id'],
      )!,
      nextHopPeerId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}next_hop_peer_id'],
      )!,
      hopCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}hop_count'],
      )!,
      qualityScore: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}quality_score'],
      )!,
      lastUsed: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_used'],
      )!,
      discoveredAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}discovered_at'],
      )!,
      expiresAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}expires_at'],
      )!,
    );
  }

  @override
  $MeshRoutesTable createAlias(String alias) {
    return $MeshRoutesTable(attachedDatabase, alias);
  }
}

class MeshRouteEntity extends DataClass implements Insertable<MeshRouteEntity> {
  /// Auto-incrementing ID
  final int id;

  /// Destination mesh peer ID
  final String destinationPeerId;

  /// Next hop peer ID (immediate neighbor to forward to)
  final String nextHopPeerId;

  /// Hop count to destination (TTL calculation)
  final int hopCount;

  /// Route quality score (based on RSSI, success rate)
  final double qualityScore;

  /// Last time this route was used successfully
  final DateTime lastUsed;

  /// When this route was discovered
  final DateTime discoveredAt;

  /// Route expires if not refreshed
  final DateTime expiresAt;
  const MeshRouteEntity({
    required this.id,
    required this.destinationPeerId,
    required this.nextHopPeerId,
    required this.hopCount,
    required this.qualityScore,
    required this.lastUsed,
    required this.discoveredAt,
    required this.expiresAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['destination_peer_id'] = Variable<String>(destinationPeerId);
    map['next_hop_peer_id'] = Variable<String>(nextHopPeerId);
    map['hop_count'] = Variable<int>(hopCount);
    map['quality_score'] = Variable<double>(qualityScore);
    map['last_used'] = Variable<DateTime>(lastUsed);
    map['discovered_at'] = Variable<DateTime>(discoveredAt);
    map['expires_at'] = Variable<DateTime>(expiresAt);
    return map;
  }

  MeshRoutesCompanion toCompanion(bool nullToAbsent) {
    return MeshRoutesCompanion(
      id: Value(id),
      destinationPeerId: Value(destinationPeerId),
      nextHopPeerId: Value(nextHopPeerId),
      hopCount: Value(hopCount),
      qualityScore: Value(qualityScore),
      lastUsed: Value(lastUsed),
      discoveredAt: Value(discoveredAt),
      expiresAt: Value(expiresAt),
    );
  }

  factory MeshRouteEntity.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return MeshRouteEntity(
      id: serializer.fromJson<int>(json['id']),
      destinationPeerId: serializer.fromJson<String>(json['destinationPeerId']),
      nextHopPeerId: serializer.fromJson<String>(json['nextHopPeerId']),
      hopCount: serializer.fromJson<int>(json['hopCount']),
      qualityScore: serializer.fromJson<double>(json['qualityScore']),
      lastUsed: serializer.fromJson<DateTime>(json['lastUsed']),
      discoveredAt: serializer.fromJson<DateTime>(json['discoveredAt']),
      expiresAt: serializer.fromJson<DateTime>(json['expiresAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'destinationPeerId': serializer.toJson<String>(destinationPeerId),
      'nextHopPeerId': serializer.toJson<String>(nextHopPeerId),
      'hopCount': serializer.toJson<int>(hopCount),
      'qualityScore': serializer.toJson<double>(qualityScore),
      'lastUsed': serializer.toJson<DateTime>(lastUsed),
      'discoveredAt': serializer.toJson<DateTime>(discoveredAt),
      'expiresAt': serializer.toJson<DateTime>(expiresAt),
    };
  }

  MeshRouteEntity copyWith({
    int? id,
    String? destinationPeerId,
    String? nextHopPeerId,
    int? hopCount,
    double? qualityScore,
    DateTime? lastUsed,
    DateTime? discoveredAt,
    DateTime? expiresAt,
  }) => MeshRouteEntity(
    id: id ?? this.id,
    destinationPeerId: destinationPeerId ?? this.destinationPeerId,
    nextHopPeerId: nextHopPeerId ?? this.nextHopPeerId,
    hopCount: hopCount ?? this.hopCount,
    qualityScore: qualityScore ?? this.qualityScore,
    lastUsed: lastUsed ?? this.lastUsed,
    discoveredAt: discoveredAt ?? this.discoveredAt,
    expiresAt: expiresAt ?? this.expiresAt,
  );
  MeshRouteEntity copyWithCompanion(MeshRoutesCompanion data) {
    return MeshRouteEntity(
      id: data.id.present ? data.id.value : this.id,
      destinationPeerId: data.destinationPeerId.present
          ? data.destinationPeerId.value
          : this.destinationPeerId,
      nextHopPeerId: data.nextHopPeerId.present
          ? data.nextHopPeerId.value
          : this.nextHopPeerId,
      hopCount: data.hopCount.present ? data.hopCount.value : this.hopCount,
      qualityScore: data.qualityScore.present
          ? data.qualityScore.value
          : this.qualityScore,
      lastUsed: data.lastUsed.present ? data.lastUsed.value : this.lastUsed,
      discoveredAt: data.discoveredAt.present
          ? data.discoveredAt.value
          : this.discoveredAt,
      expiresAt: data.expiresAt.present ? data.expiresAt.value : this.expiresAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('MeshRouteEntity(')
          ..write('id: $id, ')
          ..write('destinationPeerId: $destinationPeerId, ')
          ..write('nextHopPeerId: $nextHopPeerId, ')
          ..write('hopCount: $hopCount, ')
          ..write('qualityScore: $qualityScore, ')
          ..write('lastUsed: $lastUsed, ')
          ..write('discoveredAt: $discoveredAt, ')
          ..write('expiresAt: $expiresAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    destinationPeerId,
    nextHopPeerId,
    hopCount,
    qualityScore,
    lastUsed,
    discoveredAt,
    expiresAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is MeshRouteEntity &&
          other.id == this.id &&
          other.destinationPeerId == this.destinationPeerId &&
          other.nextHopPeerId == this.nextHopPeerId &&
          other.hopCount == this.hopCount &&
          other.qualityScore == this.qualityScore &&
          other.lastUsed == this.lastUsed &&
          other.discoveredAt == this.discoveredAt &&
          other.expiresAt == this.expiresAt);
}

class MeshRoutesCompanion extends UpdateCompanion<MeshRouteEntity> {
  final Value<int> id;
  final Value<String> destinationPeerId;
  final Value<String> nextHopPeerId;
  final Value<int> hopCount;
  final Value<double> qualityScore;
  final Value<DateTime> lastUsed;
  final Value<DateTime> discoveredAt;
  final Value<DateTime> expiresAt;
  const MeshRoutesCompanion({
    this.id = const Value.absent(),
    this.destinationPeerId = const Value.absent(),
    this.nextHopPeerId = const Value.absent(),
    this.hopCount = const Value.absent(),
    this.qualityScore = const Value.absent(),
    this.lastUsed = const Value.absent(),
    this.discoveredAt = const Value.absent(),
    this.expiresAt = const Value.absent(),
  });
  MeshRoutesCompanion.insert({
    this.id = const Value.absent(),
    required String destinationPeerId,
    required String nextHopPeerId,
    required int hopCount,
    this.qualityScore = const Value.absent(),
    required DateTime lastUsed,
    required DateTime discoveredAt,
    required DateTime expiresAt,
  }) : destinationPeerId = Value(destinationPeerId),
       nextHopPeerId = Value(nextHopPeerId),
       hopCount = Value(hopCount),
       lastUsed = Value(lastUsed),
       discoveredAt = Value(discoveredAt),
       expiresAt = Value(expiresAt);
  static Insertable<MeshRouteEntity> custom({
    Expression<int>? id,
    Expression<String>? destinationPeerId,
    Expression<String>? nextHopPeerId,
    Expression<int>? hopCount,
    Expression<double>? qualityScore,
    Expression<DateTime>? lastUsed,
    Expression<DateTime>? discoveredAt,
    Expression<DateTime>? expiresAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (destinationPeerId != null) 'destination_peer_id': destinationPeerId,
      if (nextHopPeerId != null) 'next_hop_peer_id': nextHopPeerId,
      if (hopCount != null) 'hop_count': hopCount,
      if (qualityScore != null) 'quality_score': qualityScore,
      if (lastUsed != null) 'last_used': lastUsed,
      if (discoveredAt != null) 'discovered_at': discoveredAt,
      if (expiresAt != null) 'expires_at': expiresAt,
    });
  }

  MeshRoutesCompanion copyWith({
    Value<int>? id,
    Value<String>? destinationPeerId,
    Value<String>? nextHopPeerId,
    Value<int>? hopCount,
    Value<double>? qualityScore,
    Value<DateTime>? lastUsed,
    Value<DateTime>? discoveredAt,
    Value<DateTime>? expiresAt,
  }) {
    return MeshRoutesCompanion(
      id: id ?? this.id,
      destinationPeerId: destinationPeerId ?? this.destinationPeerId,
      nextHopPeerId: nextHopPeerId ?? this.nextHopPeerId,
      hopCount: hopCount ?? this.hopCount,
      qualityScore: qualityScore ?? this.qualityScore,
      lastUsed: lastUsed ?? this.lastUsed,
      discoveredAt: discoveredAt ?? this.discoveredAt,
      expiresAt: expiresAt ?? this.expiresAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (destinationPeerId.present) {
      map['destination_peer_id'] = Variable<String>(destinationPeerId.value);
    }
    if (nextHopPeerId.present) {
      map['next_hop_peer_id'] = Variable<String>(nextHopPeerId.value);
    }
    if (hopCount.present) {
      map['hop_count'] = Variable<int>(hopCount.value);
    }
    if (qualityScore.present) {
      map['quality_score'] = Variable<double>(qualityScore.value);
    }
    if (lastUsed.present) {
      map['last_used'] = Variable<DateTime>(lastUsed.value);
    }
    if (discoveredAt.present) {
      map['discovered_at'] = Variable<DateTime>(discoveredAt.value);
    }
    if (expiresAt.present) {
      map['expires_at'] = Variable<DateTime>(expiresAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('MeshRoutesCompanion(')
          ..write('id: $id, ')
          ..write('destinationPeerId: $destinationPeerId, ')
          ..write('nextHopPeerId: $nextHopPeerId, ')
          ..write('hopCount: $hopCount, ')
          ..write('qualityScore: $qualityScore, ')
          ..write('lastUsed: $lastUsed, ')
          ..write('discoveredAt: $discoveredAt, ')
          ..write('expiresAt: $expiresAt')
          ..write(')'))
        .toString();
  }
}

class $MeshMessageQueueTable extends MeshMessageQueue
    with TableInfo<$MeshMessageQueueTable, MeshMessageQueueEntity> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $MeshMessageQueueTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _messageIdMeta = const VerificationMeta(
    'messageId',
  );
  @override
  late final GeneratedColumn<String> messageId = GeneratedColumn<String>(
    'message_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _recipientPeerIdMeta = const VerificationMeta(
    'recipientPeerId',
  );
  @override
  late final GeneratedColumn<String> recipientPeerId = GeneratedColumn<String>(
    'recipient_peer_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _encryptedPacketMeta = const VerificationMeta(
    'encryptedPacket',
  );
  @override
  late final GeneratedColumn<String> encryptedPacket = GeneratedColumn<String>(
    'encrypted_packet',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _queuedAtMeta = const VerificationMeta(
    'queuedAt',
  );
  @override
  late final GeneratedColumn<DateTime> queuedAt = GeneratedColumn<DateTime>(
    'queued_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _retryCountMeta = const VerificationMeta(
    'retryCount',
  );
  @override
  late final GeneratedColumn<int> retryCount = GeneratedColumn<int>(
    'retry_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _lastRetryAtMeta = const VerificationMeta(
    'lastRetryAt',
  );
  @override
  late final GeneratedColumn<DateTime> lastRetryAt = GeneratedColumn<DateTime>(
    'last_retry_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _expiresAtMeta = const VerificationMeta(
    'expiresAt',
  );
  @override
  late final GeneratedColumn<DateTime> expiresAt = GeneratedColumn<DateTime>(
    'expires_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    messageId,
    recipientPeerId,
    encryptedPacket,
    queuedAt,
    retryCount,
    lastRetryAt,
    expiresAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'mesh_message_queue';
  @override
  VerificationContext validateIntegrity(
    Insertable<MeshMessageQueueEntity> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('message_id')) {
      context.handle(
        _messageIdMeta,
        messageId.isAcceptableOrUnknown(data['message_id']!, _messageIdMeta),
      );
    } else if (isInserting) {
      context.missing(_messageIdMeta);
    }
    if (data.containsKey('recipient_peer_id')) {
      context.handle(
        _recipientPeerIdMeta,
        recipientPeerId.isAcceptableOrUnknown(
          data['recipient_peer_id']!,
          _recipientPeerIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_recipientPeerIdMeta);
    }
    if (data.containsKey('encrypted_packet')) {
      context.handle(
        _encryptedPacketMeta,
        encryptedPacket.isAcceptableOrUnknown(
          data['encrypted_packet']!,
          _encryptedPacketMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_encryptedPacketMeta);
    }
    if (data.containsKey('queued_at')) {
      context.handle(
        _queuedAtMeta,
        queuedAt.isAcceptableOrUnknown(data['queued_at']!, _queuedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_queuedAtMeta);
    }
    if (data.containsKey('retry_count')) {
      context.handle(
        _retryCountMeta,
        retryCount.isAcceptableOrUnknown(data['retry_count']!, _retryCountMeta),
      );
    }
    if (data.containsKey('last_retry_at')) {
      context.handle(
        _lastRetryAtMeta,
        lastRetryAt.isAcceptableOrUnknown(
          data['last_retry_at']!,
          _lastRetryAtMeta,
        ),
      );
    }
    if (data.containsKey('expires_at')) {
      context.handle(
        _expiresAtMeta,
        expiresAt.isAcceptableOrUnknown(data['expires_at']!, _expiresAtMeta),
      );
    } else if (isInserting) {
      context.missing(_expiresAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {messageId};
  @override
  MeshMessageQueueEntity map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return MeshMessageQueueEntity(
      messageId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}message_id'],
      )!,
      recipientPeerId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}recipient_peer_id'],
      )!,
      encryptedPacket: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}encrypted_packet'],
      )!,
      queuedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}queued_at'],
      )!,
      retryCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}retry_count'],
      )!,
      lastRetryAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_retry_at'],
      ),
      expiresAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}expires_at'],
      )!,
    );
  }

  @override
  $MeshMessageQueueTable createAlias(String alias) {
    return $MeshMessageQueueTable(attachedDatabase, alias);
  }
}

class MeshMessageQueueEntity extends DataClass
    implements Insertable<MeshMessageQueueEntity> {
  /// Message ID (same as Messages table)
  final String messageId;

  /// Recipient mesh peer ID
  final String recipientPeerId;

  /// Encrypted packet payload (hex encoded binary)
  final String encryptedPacket;

  /// When the message was queued
  final DateTime queuedAt;

  /// Retry count
  final int retryCount;

  /// Last retry attempt
  final DateTime? lastRetryAt;

  /// Expires after (store-and-forward TTL, max 24 hours)
  final DateTime expiresAt;
  const MeshMessageQueueEntity({
    required this.messageId,
    required this.recipientPeerId,
    required this.encryptedPacket,
    required this.queuedAt,
    required this.retryCount,
    this.lastRetryAt,
    required this.expiresAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['message_id'] = Variable<String>(messageId);
    map['recipient_peer_id'] = Variable<String>(recipientPeerId);
    map['encrypted_packet'] = Variable<String>(encryptedPacket);
    map['queued_at'] = Variable<DateTime>(queuedAt);
    map['retry_count'] = Variable<int>(retryCount);
    if (!nullToAbsent || lastRetryAt != null) {
      map['last_retry_at'] = Variable<DateTime>(lastRetryAt);
    }
    map['expires_at'] = Variable<DateTime>(expiresAt);
    return map;
  }

  MeshMessageQueueCompanion toCompanion(bool nullToAbsent) {
    return MeshMessageQueueCompanion(
      messageId: Value(messageId),
      recipientPeerId: Value(recipientPeerId),
      encryptedPacket: Value(encryptedPacket),
      queuedAt: Value(queuedAt),
      retryCount: Value(retryCount),
      lastRetryAt: lastRetryAt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastRetryAt),
      expiresAt: Value(expiresAt),
    );
  }

  factory MeshMessageQueueEntity.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return MeshMessageQueueEntity(
      messageId: serializer.fromJson<String>(json['messageId']),
      recipientPeerId: serializer.fromJson<String>(json['recipientPeerId']),
      encryptedPacket: serializer.fromJson<String>(json['encryptedPacket']),
      queuedAt: serializer.fromJson<DateTime>(json['queuedAt']),
      retryCount: serializer.fromJson<int>(json['retryCount']),
      lastRetryAt: serializer.fromJson<DateTime?>(json['lastRetryAt']),
      expiresAt: serializer.fromJson<DateTime>(json['expiresAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'messageId': serializer.toJson<String>(messageId),
      'recipientPeerId': serializer.toJson<String>(recipientPeerId),
      'encryptedPacket': serializer.toJson<String>(encryptedPacket),
      'queuedAt': serializer.toJson<DateTime>(queuedAt),
      'retryCount': serializer.toJson<int>(retryCount),
      'lastRetryAt': serializer.toJson<DateTime?>(lastRetryAt),
      'expiresAt': serializer.toJson<DateTime>(expiresAt),
    };
  }

  MeshMessageQueueEntity copyWith({
    String? messageId,
    String? recipientPeerId,
    String? encryptedPacket,
    DateTime? queuedAt,
    int? retryCount,
    Value<DateTime?> lastRetryAt = const Value.absent(),
    DateTime? expiresAt,
  }) => MeshMessageQueueEntity(
    messageId: messageId ?? this.messageId,
    recipientPeerId: recipientPeerId ?? this.recipientPeerId,
    encryptedPacket: encryptedPacket ?? this.encryptedPacket,
    queuedAt: queuedAt ?? this.queuedAt,
    retryCount: retryCount ?? this.retryCount,
    lastRetryAt: lastRetryAt.present ? lastRetryAt.value : this.lastRetryAt,
    expiresAt: expiresAt ?? this.expiresAt,
  );
  MeshMessageQueueEntity copyWithCompanion(MeshMessageQueueCompanion data) {
    return MeshMessageQueueEntity(
      messageId: data.messageId.present ? data.messageId.value : this.messageId,
      recipientPeerId: data.recipientPeerId.present
          ? data.recipientPeerId.value
          : this.recipientPeerId,
      encryptedPacket: data.encryptedPacket.present
          ? data.encryptedPacket.value
          : this.encryptedPacket,
      queuedAt: data.queuedAt.present ? data.queuedAt.value : this.queuedAt,
      retryCount: data.retryCount.present
          ? data.retryCount.value
          : this.retryCount,
      lastRetryAt: data.lastRetryAt.present
          ? data.lastRetryAt.value
          : this.lastRetryAt,
      expiresAt: data.expiresAt.present ? data.expiresAt.value : this.expiresAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('MeshMessageQueueEntity(')
          ..write('messageId: $messageId, ')
          ..write('recipientPeerId: $recipientPeerId, ')
          ..write('encryptedPacket: $encryptedPacket, ')
          ..write('queuedAt: $queuedAt, ')
          ..write('retryCount: $retryCount, ')
          ..write('lastRetryAt: $lastRetryAt, ')
          ..write('expiresAt: $expiresAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    messageId,
    recipientPeerId,
    encryptedPacket,
    queuedAt,
    retryCount,
    lastRetryAt,
    expiresAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is MeshMessageQueueEntity &&
          other.messageId == this.messageId &&
          other.recipientPeerId == this.recipientPeerId &&
          other.encryptedPacket == this.encryptedPacket &&
          other.queuedAt == this.queuedAt &&
          other.retryCount == this.retryCount &&
          other.lastRetryAt == this.lastRetryAt &&
          other.expiresAt == this.expiresAt);
}

class MeshMessageQueueCompanion
    extends UpdateCompanion<MeshMessageQueueEntity> {
  final Value<String> messageId;
  final Value<String> recipientPeerId;
  final Value<String> encryptedPacket;
  final Value<DateTime> queuedAt;
  final Value<int> retryCount;
  final Value<DateTime?> lastRetryAt;
  final Value<DateTime> expiresAt;
  final Value<int> rowid;
  const MeshMessageQueueCompanion({
    this.messageId = const Value.absent(),
    this.recipientPeerId = const Value.absent(),
    this.encryptedPacket = const Value.absent(),
    this.queuedAt = const Value.absent(),
    this.retryCount = const Value.absent(),
    this.lastRetryAt = const Value.absent(),
    this.expiresAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  MeshMessageQueueCompanion.insert({
    required String messageId,
    required String recipientPeerId,
    required String encryptedPacket,
    required DateTime queuedAt,
    this.retryCount = const Value.absent(),
    this.lastRetryAt = const Value.absent(),
    required DateTime expiresAt,
    this.rowid = const Value.absent(),
  }) : messageId = Value(messageId),
       recipientPeerId = Value(recipientPeerId),
       encryptedPacket = Value(encryptedPacket),
       queuedAt = Value(queuedAt),
       expiresAt = Value(expiresAt);
  static Insertable<MeshMessageQueueEntity> custom({
    Expression<String>? messageId,
    Expression<String>? recipientPeerId,
    Expression<String>? encryptedPacket,
    Expression<DateTime>? queuedAt,
    Expression<int>? retryCount,
    Expression<DateTime>? lastRetryAt,
    Expression<DateTime>? expiresAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (messageId != null) 'message_id': messageId,
      if (recipientPeerId != null) 'recipient_peer_id': recipientPeerId,
      if (encryptedPacket != null) 'encrypted_packet': encryptedPacket,
      if (queuedAt != null) 'queued_at': queuedAt,
      if (retryCount != null) 'retry_count': retryCount,
      if (lastRetryAt != null) 'last_retry_at': lastRetryAt,
      if (expiresAt != null) 'expires_at': expiresAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  MeshMessageQueueCompanion copyWith({
    Value<String>? messageId,
    Value<String>? recipientPeerId,
    Value<String>? encryptedPacket,
    Value<DateTime>? queuedAt,
    Value<int>? retryCount,
    Value<DateTime?>? lastRetryAt,
    Value<DateTime>? expiresAt,
    Value<int>? rowid,
  }) {
    return MeshMessageQueueCompanion(
      messageId: messageId ?? this.messageId,
      recipientPeerId: recipientPeerId ?? this.recipientPeerId,
      encryptedPacket: encryptedPacket ?? this.encryptedPacket,
      queuedAt: queuedAt ?? this.queuedAt,
      retryCount: retryCount ?? this.retryCount,
      lastRetryAt: lastRetryAt ?? this.lastRetryAt,
      expiresAt: expiresAt ?? this.expiresAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (messageId.present) {
      map['message_id'] = Variable<String>(messageId.value);
    }
    if (recipientPeerId.present) {
      map['recipient_peer_id'] = Variable<String>(recipientPeerId.value);
    }
    if (encryptedPacket.present) {
      map['encrypted_packet'] = Variable<String>(encryptedPacket.value);
    }
    if (queuedAt.present) {
      map['queued_at'] = Variable<DateTime>(queuedAt.value);
    }
    if (retryCount.present) {
      map['retry_count'] = Variable<int>(retryCount.value);
    }
    if (lastRetryAt.present) {
      map['last_retry_at'] = Variable<DateTime>(lastRetryAt.value);
    }
    if (expiresAt.present) {
      map['expires_at'] = Variable<DateTime>(expiresAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('MeshMessageQueueCompanion(')
          ..write('messageId: $messageId, ')
          ..write('recipientPeerId: $recipientPeerId, ')
          ..write('encryptedPacket: $encryptedPacket, ')
          ..write('queuedAt: $queuedAt, ')
          ..write('retryCount: $retryCount, ')
          ..write('lastRetryAt: $lastRetryAt, ')
          ..write('expiresAt: $expiresAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $MeshSeenMessagesTable extends MeshSeenMessages
    with TableInfo<$MeshSeenMessagesTable, MeshSeenMessageEntity> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $MeshSeenMessagesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _messageIdMeta = const VerificationMeta(
    'messageId',
  );
  @override
  late final GeneratedColumn<String> messageId = GeneratedColumn<String>(
    'message_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _seenAtMeta = const VerificationMeta('seenAt');
  @override
  late final GeneratedColumn<DateTime> seenAt = GeneratedColumn<DateTime>(
    'seen_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _expiresAtMeta = const VerificationMeta(
    'expiresAt',
  );
  @override
  late final GeneratedColumn<DateTime> expiresAt = GeneratedColumn<DateTime>(
    'expires_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [messageId, seenAt, expiresAt];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'mesh_seen_messages';
  @override
  VerificationContext validateIntegrity(
    Insertable<MeshSeenMessageEntity> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('message_id')) {
      context.handle(
        _messageIdMeta,
        messageId.isAcceptableOrUnknown(data['message_id']!, _messageIdMeta),
      );
    } else if (isInserting) {
      context.missing(_messageIdMeta);
    }
    if (data.containsKey('seen_at')) {
      context.handle(
        _seenAtMeta,
        seenAt.isAcceptableOrUnknown(data['seen_at']!, _seenAtMeta),
      );
    } else if (isInserting) {
      context.missing(_seenAtMeta);
    }
    if (data.containsKey('expires_at')) {
      context.handle(
        _expiresAtMeta,
        expiresAt.isAcceptableOrUnknown(data['expires_at']!, _expiresAtMeta),
      );
    } else if (isInserting) {
      context.missing(_expiresAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {messageId};
  @override
  MeshSeenMessageEntity map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return MeshSeenMessageEntity(
      messageId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}message_id'],
      )!,
      seenAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}seen_at'],
      )!,
      expiresAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}expires_at'],
      )!,
    );
  }

  @override
  $MeshSeenMessagesTable createAlias(String alias) {
    return $MeshSeenMessagesTable(attachedDatabase, alias);
  }
}

class MeshSeenMessageEntity extends DataClass
    implements Insertable<MeshSeenMessageEntity> {
  /// Message ID from packet header
  final String messageId;

  /// When we first saw this message
  final DateTime seenAt;

  /// Auto-cleanup after 1 hour (messages older than this can be forgotten)
  final DateTime expiresAt;
  const MeshSeenMessageEntity({
    required this.messageId,
    required this.seenAt,
    required this.expiresAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['message_id'] = Variable<String>(messageId);
    map['seen_at'] = Variable<DateTime>(seenAt);
    map['expires_at'] = Variable<DateTime>(expiresAt);
    return map;
  }

  MeshSeenMessagesCompanion toCompanion(bool nullToAbsent) {
    return MeshSeenMessagesCompanion(
      messageId: Value(messageId),
      seenAt: Value(seenAt),
      expiresAt: Value(expiresAt),
    );
  }

  factory MeshSeenMessageEntity.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return MeshSeenMessageEntity(
      messageId: serializer.fromJson<String>(json['messageId']),
      seenAt: serializer.fromJson<DateTime>(json['seenAt']),
      expiresAt: serializer.fromJson<DateTime>(json['expiresAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'messageId': serializer.toJson<String>(messageId),
      'seenAt': serializer.toJson<DateTime>(seenAt),
      'expiresAt': serializer.toJson<DateTime>(expiresAt),
    };
  }

  MeshSeenMessageEntity copyWith({
    String? messageId,
    DateTime? seenAt,
    DateTime? expiresAt,
  }) => MeshSeenMessageEntity(
    messageId: messageId ?? this.messageId,
    seenAt: seenAt ?? this.seenAt,
    expiresAt: expiresAt ?? this.expiresAt,
  );
  MeshSeenMessageEntity copyWithCompanion(MeshSeenMessagesCompanion data) {
    return MeshSeenMessageEntity(
      messageId: data.messageId.present ? data.messageId.value : this.messageId,
      seenAt: data.seenAt.present ? data.seenAt.value : this.seenAt,
      expiresAt: data.expiresAt.present ? data.expiresAt.value : this.expiresAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('MeshSeenMessageEntity(')
          ..write('messageId: $messageId, ')
          ..write('seenAt: $seenAt, ')
          ..write('expiresAt: $expiresAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(messageId, seenAt, expiresAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is MeshSeenMessageEntity &&
          other.messageId == this.messageId &&
          other.seenAt == this.seenAt &&
          other.expiresAt == this.expiresAt);
}

class MeshSeenMessagesCompanion extends UpdateCompanion<MeshSeenMessageEntity> {
  final Value<String> messageId;
  final Value<DateTime> seenAt;
  final Value<DateTime> expiresAt;
  final Value<int> rowid;
  const MeshSeenMessagesCompanion({
    this.messageId = const Value.absent(),
    this.seenAt = const Value.absent(),
    this.expiresAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  MeshSeenMessagesCompanion.insert({
    required String messageId,
    required DateTime seenAt,
    required DateTime expiresAt,
    this.rowid = const Value.absent(),
  }) : messageId = Value(messageId),
       seenAt = Value(seenAt),
       expiresAt = Value(expiresAt);
  static Insertable<MeshSeenMessageEntity> custom({
    Expression<String>? messageId,
    Expression<DateTime>? seenAt,
    Expression<DateTime>? expiresAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (messageId != null) 'message_id': messageId,
      if (seenAt != null) 'seen_at': seenAt,
      if (expiresAt != null) 'expires_at': expiresAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  MeshSeenMessagesCompanion copyWith({
    Value<String>? messageId,
    Value<DateTime>? seenAt,
    Value<DateTime>? expiresAt,
    Value<int>? rowid,
  }) {
    return MeshSeenMessagesCompanion(
      messageId: messageId ?? this.messageId,
      seenAt: seenAt ?? this.seenAt,
      expiresAt: expiresAt ?? this.expiresAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (messageId.present) {
      map['message_id'] = Variable<String>(messageId.value);
    }
    if (seenAt.present) {
      map['seen_at'] = Variable<DateTime>(seenAt.value);
    }
    if (expiresAt.present) {
      map['expires_at'] = Variable<DateTime>(expiresAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('MeshSeenMessagesCompanion(')
          ..write('messageId: $messageId, ')
          ..write('seenAt: $seenAt, ')
          ..write('expiresAt: $expiresAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $RallyChannelMembersTable extends RallyChannelMembers
    with TableInfo<$RallyChannelMembersTable, RallyChannelMemberEntity> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $RallyChannelMembersTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _channelIdMeta = const VerificationMeta(
    'channelId',
  );
  @override
  late final GeneratedColumn<String> channelId = GeneratedColumn<String>(
    'channel_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES conversations (id)',
    ),
  );
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<String> userId = GeneratedColumn<String>(
    'user_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _displayNameMeta = const VerificationMeta(
    'displayName',
  );
  @override
  late final GeneratedColumn<String> displayName = GeneratedColumn<String>(
    'display_name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _identityTypeMeta = const VerificationMeta(
    'identityType',
  );
  @override
  late final GeneratedColumn<String> identityType = GeneratedColumn<String>(
    'identity_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _joinedAtMeta = const VerificationMeta(
    'joinedAt',
  );
  @override
  late final GeneratedColumn<DateTime> joinedAt = GeneratedColumn<DateTime>(
    'joined_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _lastSeenAtMeta = const VerificationMeta(
    'lastSeenAt',
  );
  @override
  late final GeneratedColumn<DateTime> lastSeenAt = GeneratedColumn<DateTime>(
    'last_seen_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _messageCountMeta = const VerificationMeta(
    'messageCount',
  );
  @override
  late final GeneratedColumn<int> messageCount = GeneratedColumn<int>(
    'message_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _reputationScoreMeta = const VerificationMeta(
    'reputationScore',
  );
  @override
  late final GeneratedColumn<int> reputationScore = GeneratedColumn<int>(
    'reputation_score',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(50),
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    channelId,
    userId,
    displayName,
    identityType,
    joinedAt,
    lastSeenAt,
    messageCount,
    reputationScore,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'rally_channel_members';
  @override
  VerificationContext validateIntegrity(
    Insertable<RallyChannelMemberEntity> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('channel_id')) {
      context.handle(
        _channelIdMeta,
        channelId.isAcceptableOrUnknown(data['channel_id']!, _channelIdMeta),
      );
    } else if (isInserting) {
      context.missing(_channelIdMeta);
    }
    if (data.containsKey('user_id')) {
      context.handle(
        _userIdMeta,
        userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta),
      );
    } else if (isInserting) {
      context.missing(_userIdMeta);
    }
    if (data.containsKey('display_name')) {
      context.handle(
        _displayNameMeta,
        displayName.isAcceptableOrUnknown(
          data['display_name']!,
          _displayNameMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_displayNameMeta);
    }
    if (data.containsKey('identity_type')) {
      context.handle(
        _identityTypeMeta,
        identityType.isAcceptableOrUnknown(
          data['identity_type']!,
          _identityTypeMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_identityTypeMeta);
    }
    if (data.containsKey('joined_at')) {
      context.handle(
        _joinedAtMeta,
        joinedAt.isAcceptableOrUnknown(data['joined_at']!, _joinedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_joinedAtMeta);
    }
    if (data.containsKey('last_seen_at')) {
      context.handle(
        _lastSeenAtMeta,
        lastSeenAt.isAcceptableOrUnknown(
          data['last_seen_at']!,
          _lastSeenAtMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_lastSeenAtMeta);
    }
    if (data.containsKey('message_count')) {
      context.handle(
        _messageCountMeta,
        messageCount.isAcceptableOrUnknown(
          data['message_count']!,
          _messageCountMeta,
        ),
      );
    }
    if (data.containsKey('reputation_score')) {
      context.handle(
        _reputationScoreMeta,
        reputationScore.isAcceptableOrUnknown(
          data['reputation_score']!,
          _reputationScoreMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
    {channelId, userId},
  ];
  @override
  RallyChannelMemberEntity map(
    Map<String, dynamic> data, {
    String? tablePrefix,
  }) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return RallyChannelMemberEntity(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      channelId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}channel_id'],
      )!,
      userId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}user_id'],
      )!,
      displayName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}display_name'],
      )!,
      identityType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}identity_type'],
      )!,
      joinedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}joined_at'],
      )!,
      lastSeenAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_seen_at'],
      )!,
      messageCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}message_count'],
      )!,
      reputationScore: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}reputation_score'],
      )!,
    );
  }

  @override
  $RallyChannelMembersTable createAlias(String alias) {
    return $RallyChannelMembersTable(attachedDatabase, alias);
  }
}

class RallyChannelMemberEntity extends DataClass
    implements Insertable<RallyChannelMemberEntity> {
  /// Auto-incrementing ID
  final int id;

  /// Rally channel ID
  final String channelId;

  /// User ID (mesh peer ID or anonymous ID)
  final String userId;

  /// Display name (anonymous/pseudonymous/real)
  final String displayName;

  /// Identity type (anonymous, pseudonymous, verified)
  final String identityType;

  /// When the user joined the channel
  final DateTime joinedAt;

  /// Last time the user was active in the channel
  final DateTime lastSeenAt;

  /// Number of messages posted by this user
  final int messageCount;

  /// Local reputation score (0-100)
  final int reputationScore;
  const RallyChannelMemberEntity({
    required this.id,
    required this.channelId,
    required this.userId,
    required this.displayName,
    required this.identityType,
    required this.joinedAt,
    required this.lastSeenAt,
    required this.messageCount,
    required this.reputationScore,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['channel_id'] = Variable<String>(channelId);
    map['user_id'] = Variable<String>(userId);
    map['display_name'] = Variable<String>(displayName);
    map['identity_type'] = Variable<String>(identityType);
    map['joined_at'] = Variable<DateTime>(joinedAt);
    map['last_seen_at'] = Variable<DateTime>(lastSeenAt);
    map['message_count'] = Variable<int>(messageCount);
    map['reputation_score'] = Variable<int>(reputationScore);
    return map;
  }

  RallyChannelMembersCompanion toCompanion(bool nullToAbsent) {
    return RallyChannelMembersCompanion(
      id: Value(id),
      channelId: Value(channelId),
      userId: Value(userId),
      displayName: Value(displayName),
      identityType: Value(identityType),
      joinedAt: Value(joinedAt),
      lastSeenAt: Value(lastSeenAt),
      messageCount: Value(messageCount),
      reputationScore: Value(reputationScore),
    );
  }

  factory RallyChannelMemberEntity.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return RallyChannelMemberEntity(
      id: serializer.fromJson<int>(json['id']),
      channelId: serializer.fromJson<String>(json['channelId']),
      userId: serializer.fromJson<String>(json['userId']),
      displayName: serializer.fromJson<String>(json['displayName']),
      identityType: serializer.fromJson<String>(json['identityType']),
      joinedAt: serializer.fromJson<DateTime>(json['joinedAt']),
      lastSeenAt: serializer.fromJson<DateTime>(json['lastSeenAt']),
      messageCount: serializer.fromJson<int>(json['messageCount']),
      reputationScore: serializer.fromJson<int>(json['reputationScore']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'channelId': serializer.toJson<String>(channelId),
      'userId': serializer.toJson<String>(userId),
      'displayName': serializer.toJson<String>(displayName),
      'identityType': serializer.toJson<String>(identityType),
      'joinedAt': serializer.toJson<DateTime>(joinedAt),
      'lastSeenAt': serializer.toJson<DateTime>(lastSeenAt),
      'messageCount': serializer.toJson<int>(messageCount),
      'reputationScore': serializer.toJson<int>(reputationScore),
    };
  }

  RallyChannelMemberEntity copyWith({
    int? id,
    String? channelId,
    String? userId,
    String? displayName,
    String? identityType,
    DateTime? joinedAt,
    DateTime? lastSeenAt,
    int? messageCount,
    int? reputationScore,
  }) => RallyChannelMemberEntity(
    id: id ?? this.id,
    channelId: channelId ?? this.channelId,
    userId: userId ?? this.userId,
    displayName: displayName ?? this.displayName,
    identityType: identityType ?? this.identityType,
    joinedAt: joinedAt ?? this.joinedAt,
    lastSeenAt: lastSeenAt ?? this.lastSeenAt,
    messageCount: messageCount ?? this.messageCount,
    reputationScore: reputationScore ?? this.reputationScore,
  );
  RallyChannelMemberEntity copyWithCompanion(
    RallyChannelMembersCompanion data,
  ) {
    return RallyChannelMemberEntity(
      id: data.id.present ? data.id.value : this.id,
      channelId: data.channelId.present ? data.channelId.value : this.channelId,
      userId: data.userId.present ? data.userId.value : this.userId,
      displayName: data.displayName.present
          ? data.displayName.value
          : this.displayName,
      identityType: data.identityType.present
          ? data.identityType.value
          : this.identityType,
      joinedAt: data.joinedAt.present ? data.joinedAt.value : this.joinedAt,
      lastSeenAt: data.lastSeenAt.present
          ? data.lastSeenAt.value
          : this.lastSeenAt,
      messageCount: data.messageCount.present
          ? data.messageCount.value
          : this.messageCount,
      reputationScore: data.reputationScore.present
          ? data.reputationScore.value
          : this.reputationScore,
    );
  }

  @override
  String toString() {
    return (StringBuffer('RallyChannelMemberEntity(')
          ..write('id: $id, ')
          ..write('channelId: $channelId, ')
          ..write('userId: $userId, ')
          ..write('displayName: $displayName, ')
          ..write('identityType: $identityType, ')
          ..write('joinedAt: $joinedAt, ')
          ..write('lastSeenAt: $lastSeenAt, ')
          ..write('messageCount: $messageCount, ')
          ..write('reputationScore: $reputationScore')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    channelId,
    userId,
    displayName,
    identityType,
    joinedAt,
    lastSeenAt,
    messageCount,
    reputationScore,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is RallyChannelMemberEntity &&
          other.id == this.id &&
          other.channelId == this.channelId &&
          other.userId == this.userId &&
          other.displayName == this.displayName &&
          other.identityType == this.identityType &&
          other.joinedAt == this.joinedAt &&
          other.lastSeenAt == this.lastSeenAt &&
          other.messageCount == this.messageCount &&
          other.reputationScore == this.reputationScore);
}

class RallyChannelMembersCompanion
    extends UpdateCompanion<RallyChannelMemberEntity> {
  final Value<int> id;
  final Value<String> channelId;
  final Value<String> userId;
  final Value<String> displayName;
  final Value<String> identityType;
  final Value<DateTime> joinedAt;
  final Value<DateTime> lastSeenAt;
  final Value<int> messageCount;
  final Value<int> reputationScore;
  const RallyChannelMembersCompanion({
    this.id = const Value.absent(),
    this.channelId = const Value.absent(),
    this.userId = const Value.absent(),
    this.displayName = const Value.absent(),
    this.identityType = const Value.absent(),
    this.joinedAt = const Value.absent(),
    this.lastSeenAt = const Value.absent(),
    this.messageCount = const Value.absent(),
    this.reputationScore = const Value.absent(),
  });
  RallyChannelMembersCompanion.insert({
    this.id = const Value.absent(),
    required String channelId,
    required String userId,
    required String displayName,
    required String identityType,
    required DateTime joinedAt,
    required DateTime lastSeenAt,
    this.messageCount = const Value.absent(),
    this.reputationScore = const Value.absent(),
  }) : channelId = Value(channelId),
       userId = Value(userId),
       displayName = Value(displayName),
       identityType = Value(identityType),
       joinedAt = Value(joinedAt),
       lastSeenAt = Value(lastSeenAt);
  static Insertable<RallyChannelMemberEntity> custom({
    Expression<int>? id,
    Expression<String>? channelId,
    Expression<String>? userId,
    Expression<String>? displayName,
    Expression<String>? identityType,
    Expression<DateTime>? joinedAt,
    Expression<DateTime>? lastSeenAt,
    Expression<int>? messageCount,
    Expression<int>? reputationScore,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (channelId != null) 'channel_id': channelId,
      if (userId != null) 'user_id': userId,
      if (displayName != null) 'display_name': displayName,
      if (identityType != null) 'identity_type': identityType,
      if (joinedAt != null) 'joined_at': joinedAt,
      if (lastSeenAt != null) 'last_seen_at': lastSeenAt,
      if (messageCount != null) 'message_count': messageCount,
      if (reputationScore != null) 'reputation_score': reputationScore,
    });
  }

  RallyChannelMembersCompanion copyWith({
    Value<int>? id,
    Value<String>? channelId,
    Value<String>? userId,
    Value<String>? displayName,
    Value<String>? identityType,
    Value<DateTime>? joinedAt,
    Value<DateTime>? lastSeenAt,
    Value<int>? messageCount,
    Value<int>? reputationScore,
  }) {
    return RallyChannelMembersCompanion(
      id: id ?? this.id,
      channelId: channelId ?? this.channelId,
      userId: userId ?? this.userId,
      displayName: displayName ?? this.displayName,
      identityType: identityType ?? this.identityType,
      joinedAt: joinedAt ?? this.joinedAt,
      lastSeenAt: lastSeenAt ?? this.lastSeenAt,
      messageCount: messageCount ?? this.messageCount,
      reputationScore: reputationScore ?? this.reputationScore,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (channelId.present) {
      map['channel_id'] = Variable<String>(channelId.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<String>(userId.value);
    }
    if (displayName.present) {
      map['display_name'] = Variable<String>(displayName.value);
    }
    if (identityType.present) {
      map['identity_type'] = Variable<String>(identityType.value);
    }
    if (joinedAt.present) {
      map['joined_at'] = Variable<DateTime>(joinedAt.value);
    }
    if (lastSeenAt.present) {
      map['last_seen_at'] = Variable<DateTime>(lastSeenAt.value);
    }
    if (messageCount.present) {
      map['message_count'] = Variable<int>(messageCount.value);
    }
    if (reputationScore.present) {
      map['reputation_score'] = Variable<int>(reputationScore.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('RallyChannelMembersCompanion(')
          ..write('id: $id, ')
          ..write('channelId: $channelId, ')
          ..write('userId: $userId, ')
          ..write('displayName: $displayName, ')
          ..write('identityType: $identityType, ')
          ..write('joinedAt: $joinedAt, ')
          ..write('lastSeenAt: $lastSeenAt, ')
          ..write('messageCount: $messageCount, ')
          ..write('reputationScore: $reputationScore')
          ..write(')'))
        .toString();
  }
}

class $RallyReportsTable extends RallyReports
    with TableInfo<$RallyReportsTable, RallyReportEntity> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $RallyReportsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _reporterIdMeta = const VerificationMeta(
    'reporterId',
  );
  @override
  late final GeneratedColumn<String> reporterId = GeneratedColumn<String>(
    'reporter_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _reportedUserIdMeta = const VerificationMeta(
    'reportedUserId',
  );
  @override
  late final GeneratedColumn<String> reportedUserId = GeneratedColumn<String>(
    'reported_user_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _messageIdMeta = const VerificationMeta(
    'messageId',
  );
  @override
  late final GeneratedColumn<String> messageId = GeneratedColumn<String>(
    'message_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _categoryMeta = const VerificationMeta(
    'category',
  );
  @override
  late final GeneratedColumn<String> category = GeneratedColumn<String>(
    'category',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
    'notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _reportedAtMeta = const VerificationMeta(
    'reportedAt',
  );
  @override
  late final GeneratedColumn<DateTime> reportedAt = GeneratedColumn<DateTime>(
    'reported_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _isUploadedMeta = const VerificationMeta(
    'isUploaded',
  );
  @override
  late final GeneratedColumn<bool> isUploaded = GeneratedColumn<bool>(
    'is_uploaded',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_uploaded" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    reporterId,
    reportedUserId,
    messageId,
    category,
    notes,
    reportedAt,
    isUploaded,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'rally_reports';
  @override
  VerificationContext validateIntegrity(
    Insertable<RallyReportEntity> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('reporter_id')) {
      context.handle(
        _reporterIdMeta,
        reporterId.isAcceptableOrUnknown(data['reporter_id']!, _reporterIdMeta),
      );
    } else if (isInserting) {
      context.missing(_reporterIdMeta);
    }
    if (data.containsKey('reported_user_id')) {
      context.handle(
        _reportedUserIdMeta,
        reportedUserId.isAcceptableOrUnknown(
          data['reported_user_id']!,
          _reportedUserIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_reportedUserIdMeta);
    }
    if (data.containsKey('message_id')) {
      context.handle(
        _messageIdMeta,
        messageId.isAcceptableOrUnknown(data['message_id']!, _messageIdMeta),
      );
    }
    if (data.containsKey('category')) {
      context.handle(
        _categoryMeta,
        category.isAcceptableOrUnknown(data['category']!, _categoryMeta),
      );
    } else if (isInserting) {
      context.missing(_categoryMeta);
    }
    if (data.containsKey('notes')) {
      context.handle(
        _notesMeta,
        notes.isAcceptableOrUnknown(data['notes']!, _notesMeta),
      );
    }
    if (data.containsKey('reported_at')) {
      context.handle(
        _reportedAtMeta,
        reportedAt.isAcceptableOrUnknown(data['reported_at']!, _reportedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_reportedAtMeta);
    }
    if (data.containsKey('is_uploaded')) {
      context.handle(
        _isUploadedMeta,
        isUploaded.isAcceptableOrUnknown(data['is_uploaded']!, _isUploadedMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  RallyReportEntity map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return RallyReportEntity(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      reporterId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}reporter_id'],
      )!,
      reportedUserId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}reported_user_id'],
      )!,
      messageId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}message_id'],
      ),
      category: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}category'],
      )!,
      notes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notes'],
      ),
      reportedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}reported_at'],
      )!,
      isUploaded: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_uploaded'],
      )!,
    );
  }

  @override
  $RallyReportsTable createAlias(String alias) {
    return $RallyReportsTable(attachedDatabase, alias);
  }
}

class RallyReportEntity extends DataClass
    implements Insertable<RallyReportEntity> {
  /// Auto-incrementing ID
  final int id;

  /// Who reported
  final String reporterId;

  /// Who was reported
  final String reportedUserId;

  /// Optional message ID
  final String? messageId;

  /// Report category (spam, harassment, threats, csam)
  final String category;

  /// Additional notes
  final String? notes;

  /// When the report was made
  final DateTime reportedAt;

  /// Whether report was uploaded to authorities (for credible threats)
  final bool isUploaded;
  const RallyReportEntity({
    required this.id,
    required this.reporterId,
    required this.reportedUserId,
    this.messageId,
    required this.category,
    this.notes,
    required this.reportedAt,
    required this.isUploaded,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['reporter_id'] = Variable<String>(reporterId);
    map['reported_user_id'] = Variable<String>(reportedUserId);
    if (!nullToAbsent || messageId != null) {
      map['message_id'] = Variable<String>(messageId);
    }
    map['category'] = Variable<String>(category);
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    map['reported_at'] = Variable<DateTime>(reportedAt);
    map['is_uploaded'] = Variable<bool>(isUploaded);
    return map;
  }

  RallyReportsCompanion toCompanion(bool nullToAbsent) {
    return RallyReportsCompanion(
      id: Value(id),
      reporterId: Value(reporterId),
      reportedUserId: Value(reportedUserId),
      messageId: messageId == null && nullToAbsent
          ? const Value.absent()
          : Value(messageId),
      category: Value(category),
      notes: notes == null && nullToAbsent
          ? const Value.absent()
          : Value(notes),
      reportedAt: Value(reportedAt),
      isUploaded: Value(isUploaded),
    );
  }

  factory RallyReportEntity.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return RallyReportEntity(
      id: serializer.fromJson<int>(json['id']),
      reporterId: serializer.fromJson<String>(json['reporterId']),
      reportedUserId: serializer.fromJson<String>(json['reportedUserId']),
      messageId: serializer.fromJson<String?>(json['messageId']),
      category: serializer.fromJson<String>(json['category']),
      notes: serializer.fromJson<String?>(json['notes']),
      reportedAt: serializer.fromJson<DateTime>(json['reportedAt']),
      isUploaded: serializer.fromJson<bool>(json['isUploaded']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'reporterId': serializer.toJson<String>(reporterId),
      'reportedUserId': serializer.toJson<String>(reportedUserId),
      'messageId': serializer.toJson<String?>(messageId),
      'category': serializer.toJson<String>(category),
      'notes': serializer.toJson<String?>(notes),
      'reportedAt': serializer.toJson<DateTime>(reportedAt),
      'isUploaded': serializer.toJson<bool>(isUploaded),
    };
  }

  RallyReportEntity copyWith({
    int? id,
    String? reporterId,
    String? reportedUserId,
    Value<String?> messageId = const Value.absent(),
    String? category,
    Value<String?> notes = const Value.absent(),
    DateTime? reportedAt,
    bool? isUploaded,
  }) => RallyReportEntity(
    id: id ?? this.id,
    reporterId: reporterId ?? this.reporterId,
    reportedUserId: reportedUserId ?? this.reportedUserId,
    messageId: messageId.present ? messageId.value : this.messageId,
    category: category ?? this.category,
    notes: notes.present ? notes.value : this.notes,
    reportedAt: reportedAt ?? this.reportedAt,
    isUploaded: isUploaded ?? this.isUploaded,
  );
  RallyReportEntity copyWithCompanion(RallyReportsCompanion data) {
    return RallyReportEntity(
      id: data.id.present ? data.id.value : this.id,
      reporterId: data.reporterId.present
          ? data.reporterId.value
          : this.reporterId,
      reportedUserId: data.reportedUserId.present
          ? data.reportedUserId.value
          : this.reportedUserId,
      messageId: data.messageId.present ? data.messageId.value : this.messageId,
      category: data.category.present ? data.category.value : this.category,
      notes: data.notes.present ? data.notes.value : this.notes,
      reportedAt: data.reportedAt.present
          ? data.reportedAt.value
          : this.reportedAt,
      isUploaded: data.isUploaded.present
          ? data.isUploaded.value
          : this.isUploaded,
    );
  }

  @override
  String toString() {
    return (StringBuffer('RallyReportEntity(')
          ..write('id: $id, ')
          ..write('reporterId: $reporterId, ')
          ..write('reportedUserId: $reportedUserId, ')
          ..write('messageId: $messageId, ')
          ..write('category: $category, ')
          ..write('notes: $notes, ')
          ..write('reportedAt: $reportedAt, ')
          ..write('isUploaded: $isUploaded')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    reporterId,
    reportedUserId,
    messageId,
    category,
    notes,
    reportedAt,
    isUploaded,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is RallyReportEntity &&
          other.id == this.id &&
          other.reporterId == this.reporterId &&
          other.reportedUserId == this.reportedUserId &&
          other.messageId == this.messageId &&
          other.category == this.category &&
          other.notes == this.notes &&
          other.reportedAt == this.reportedAt &&
          other.isUploaded == this.isUploaded);
}

class RallyReportsCompanion extends UpdateCompanion<RallyReportEntity> {
  final Value<int> id;
  final Value<String> reporterId;
  final Value<String> reportedUserId;
  final Value<String?> messageId;
  final Value<String> category;
  final Value<String?> notes;
  final Value<DateTime> reportedAt;
  final Value<bool> isUploaded;
  const RallyReportsCompanion({
    this.id = const Value.absent(),
    this.reporterId = const Value.absent(),
    this.reportedUserId = const Value.absent(),
    this.messageId = const Value.absent(),
    this.category = const Value.absent(),
    this.notes = const Value.absent(),
    this.reportedAt = const Value.absent(),
    this.isUploaded = const Value.absent(),
  });
  RallyReportsCompanion.insert({
    this.id = const Value.absent(),
    required String reporterId,
    required String reportedUserId,
    this.messageId = const Value.absent(),
    required String category,
    this.notes = const Value.absent(),
    required DateTime reportedAt,
    this.isUploaded = const Value.absent(),
  }) : reporterId = Value(reporterId),
       reportedUserId = Value(reportedUserId),
       category = Value(category),
       reportedAt = Value(reportedAt);
  static Insertable<RallyReportEntity> custom({
    Expression<int>? id,
    Expression<String>? reporterId,
    Expression<String>? reportedUserId,
    Expression<String>? messageId,
    Expression<String>? category,
    Expression<String>? notes,
    Expression<DateTime>? reportedAt,
    Expression<bool>? isUploaded,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (reporterId != null) 'reporter_id': reporterId,
      if (reportedUserId != null) 'reported_user_id': reportedUserId,
      if (messageId != null) 'message_id': messageId,
      if (category != null) 'category': category,
      if (notes != null) 'notes': notes,
      if (reportedAt != null) 'reported_at': reportedAt,
      if (isUploaded != null) 'is_uploaded': isUploaded,
    });
  }

  RallyReportsCompanion copyWith({
    Value<int>? id,
    Value<String>? reporterId,
    Value<String>? reportedUserId,
    Value<String?>? messageId,
    Value<String>? category,
    Value<String?>? notes,
    Value<DateTime>? reportedAt,
    Value<bool>? isUploaded,
  }) {
    return RallyReportsCompanion(
      id: id ?? this.id,
      reporterId: reporterId ?? this.reporterId,
      reportedUserId: reportedUserId ?? this.reportedUserId,
      messageId: messageId ?? this.messageId,
      category: category ?? this.category,
      notes: notes ?? this.notes,
      reportedAt: reportedAt ?? this.reportedAt,
      isUploaded: isUploaded ?? this.isUploaded,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (reporterId.present) {
      map['reporter_id'] = Variable<String>(reporterId.value);
    }
    if (reportedUserId.present) {
      map['reported_user_id'] = Variable<String>(reportedUserId.value);
    }
    if (messageId.present) {
      map['message_id'] = Variable<String>(messageId.value);
    }
    if (category.present) {
      map['category'] = Variable<String>(category.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (reportedAt.present) {
      map['reported_at'] = Variable<DateTime>(reportedAt.value);
    }
    if (isUploaded.present) {
      map['is_uploaded'] = Variable<bool>(isUploaded.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('RallyReportsCompanion(')
          ..write('id: $id, ')
          ..write('reporterId: $reporterId, ')
          ..write('reportedUserId: $reportedUserId, ')
          ..write('messageId: $messageId, ')
          ..write('category: $category, ')
          ..write('notes: $notes, ')
          ..write('reportedAt: $reportedAt, ')
          ..write('isUploaded: $isUploaded')
          ..write(')'))
        .toString();
  }
}

abstract class _$AppDatabase extends GeneratedDatabase {
  _$AppDatabase(QueryExecutor e) : super(e);
  $AppDatabaseManager get managers => $AppDatabaseManager(this);
  late final $ContactsTable contacts = $ContactsTable(this);
  late final $ConversationsTable conversations = $ConversationsTable(this);
  late final $MessagesTable messages = $MessagesTable(this);
  late final $GroupMembersTable groupMembers = $GroupMembersTable(this);
  late final $MeshPeersTable meshPeers = $MeshPeersTable(this);
  late final $MeshRoutesTable meshRoutes = $MeshRoutesTable(this);
  late final $MeshMessageQueueTable meshMessageQueue = $MeshMessageQueueTable(
    this,
  );
  late final $MeshSeenMessagesTable meshSeenMessages = $MeshSeenMessagesTable(
    this,
  );
  late final $RallyChannelMembersTable rallyChannelMembers =
      $RallyChannelMembersTable(this);
  late final $RallyReportsTable rallyReports = $RallyReportsTable(this);
  @override
  Iterable<TableInfo<Table, Object?>> get allTables =>
      allSchemaEntities.whereType<TableInfo<Table, Object?>>();
  @override
  List<DatabaseSchemaEntity> get allSchemaEntities => [
    contacts,
    conversations,
    messages,
    groupMembers,
    meshPeers,
    meshRoutes,
    meshMessageQueue,
    meshSeenMessages,
    rallyChannelMembers,
    rallyReports,
  ];
}

typedef $$ContactsTableCreateCompanionBuilder =
    ContactsCompanion Function({
      required String id,
      required String displayName,
      Value<String?> avatar,
      required String publicKey,
      required String exchangePublicKey,
      Value<String> verificationStatus,
      required DateTime createdAt,
      Value<DateTime?> lastSeen,
      Value<bool> isBlocked,
      Value<int?> lastMeshRssi,
      Value<DateTime?> lastMeshSeen,
      Value<int?> lastMeshHopCount,
      Value<String?> preferredTransport,
      Value<int> rowid,
    });
typedef $$ContactsTableUpdateCompanionBuilder =
    ContactsCompanion Function({
      Value<String> id,
      Value<String> displayName,
      Value<String?> avatar,
      Value<String> publicKey,
      Value<String> exchangePublicKey,
      Value<String> verificationStatus,
      Value<DateTime> createdAt,
      Value<DateTime?> lastSeen,
      Value<bool> isBlocked,
      Value<int?> lastMeshRssi,
      Value<DateTime?> lastMeshSeen,
      Value<int?> lastMeshHopCount,
      Value<String?> preferredTransport,
      Value<int> rowid,
    });

final class $$ContactsTableReferences
    extends BaseReferences<_$AppDatabase, $ContactsTable, ContactEntity> {
  $$ContactsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$GroupMembersTable, List<GroupMemberEntity>>
  _groupMembersRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.groupMembers,
    aliasName: $_aliasNameGenerator(db.contacts.id, db.groupMembers.contactId),
  );

  $$GroupMembersTableProcessedTableManager get groupMembersRefs {
    final manager = $$GroupMembersTableTableManager(
      $_db,
      $_db.groupMembers,
    ).filter((f) => f.contactId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_groupMembersRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$MeshPeersTable, List<MeshPeerEntity>>
  _meshPeersRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.meshPeers,
    aliasName: $_aliasNameGenerator(db.contacts.id, db.meshPeers.contactId),
  );

  $$MeshPeersTableProcessedTableManager get meshPeersRefs {
    final manager = $$MeshPeersTableTableManager(
      $_db,
      $_db.meshPeers,
    ).filter((f) => f.contactId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_meshPeersRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$ContactsTableFilterComposer
    extends Composer<_$AppDatabase, $ContactsTable> {
  $$ContactsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get displayName => $composableBuilder(
    column: $table.displayName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get avatar => $composableBuilder(
    column: $table.avatar,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get publicKey => $composableBuilder(
    column: $table.publicKey,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get exchangePublicKey => $composableBuilder(
    column: $table.exchangePublicKey,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get verificationStatus => $composableBuilder(
    column: $table.verificationStatus,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastSeen => $composableBuilder(
    column: $table.lastSeen,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isBlocked => $composableBuilder(
    column: $table.isBlocked,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get lastMeshRssi => $composableBuilder(
    column: $table.lastMeshRssi,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastMeshSeen => $composableBuilder(
    column: $table.lastMeshSeen,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get lastMeshHopCount => $composableBuilder(
    column: $table.lastMeshHopCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get preferredTransport => $composableBuilder(
    column: $table.preferredTransport,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> groupMembersRefs(
    Expression<bool> Function($$GroupMembersTableFilterComposer f) f,
  ) {
    final $$GroupMembersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.groupMembers,
      getReferencedColumn: (t) => t.contactId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$GroupMembersTableFilterComposer(
            $db: $db,
            $table: $db.groupMembers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> meshPeersRefs(
    Expression<bool> Function($$MeshPeersTableFilterComposer f) f,
  ) {
    final $$MeshPeersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.meshPeers,
      getReferencedColumn: (t) => t.contactId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$MeshPeersTableFilterComposer(
            $db: $db,
            $table: $db.meshPeers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$ContactsTableOrderingComposer
    extends Composer<_$AppDatabase, $ContactsTable> {
  $$ContactsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get displayName => $composableBuilder(
    column: $table.displayName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get avatar => $composableBuilder(
    column: $table.avatar,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get publicKey => $composableBuilder(
    column: $table.publicKey,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get exchangePublicKey => $composableBuilder(
    column: $table.exchangePublicKey,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get verificationStatus => $composableBuilder(
    column: $table.verificationStatus,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastSeen => $composableBuilder(
    column: $table.lastSeen,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isBlocked => $composableBuilder(
    column: $table.isBlocked,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get lastMeshRssi => $composableBuilder(
    column: $table.lastMeshRssi,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastMeshSeen => $composableBuilder(
    column: $table.lastMeshSeen,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get lastMeshHopCount => $composableBuilder(
    column: $table.lastMeshHopCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get preferredTransport => $composableBuilder(
    column: $table.preferredTransport,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$ContactsTableAnnotationComposer
    extends Composer<_$AppDatabase, $ContactsTable> {
  $$ContactsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get displayName => $composableBuilder(
    column: $table.displayName,
    builder: (column) => column,
  );

  GeneratedColumn<String> get avatar =>
      $composableBuilder(column: $table.avatar, builder: (column) => column);

  GeneratedColumn<String> get publicKey =>
      $composableBuilder(column: $table.publicKey, builder: (column) => column);

  GeneratedColumn<String> get exchangePublicKey => $composableBuilder(
    column: $table.exchangePublicKey,
    builder: (column) => column,
  );

  GeneratedColumn<String> get verificationStatus => $composableBuilder(
    column: $table.verificationStatus,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get lastSeen =>
      $composableBuilder(column: $table.lastSeen, builder: (column) => column);

  GeneratedColumn<bool> get isBlocked =>
      $composableBuilder(column: $table.isBlocked, builder: (column) => column);

  GeneratedColumn<int> get lastMeshRssi => $composableBuilder(
    column: $table.lastMeshRssi,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get lastMeshSeen => $composableBuilder(
    column: $table.lastMeshSeen,
    builder: (column) => column,
  );

  GeneratedColumn<int> get lastMeshHopCount => $composableBuilder(
    column: $table.lastMeshHopCount,
    builder: (column) => column,
  );

  GeneratedColumn<String> get preferredTransport => $composableBuilder(
    column: $table.preferredTransport,
    builder: (column) => column,
  );

  Expression<T> groupMembersRefs<T extends Object>(
    Expression<T> Function($$GroupMembersTableAnnotationComposer a) f,
  ) {
    final $$GroupMembersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.groupMembers,
      getReferencedColumn: (t) => t.contactId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$GroupMembersTableAnnotationComposer(
            $db: $db,
            $table: $db.groupMembers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> meshPeersRefs<T extends Object>(
    Expression<T> Function($$MeshPeersTableAnnotationComposer a) f,
  ) {
    final $$MeshPeersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.meshPeers,
      getReferencedColumn: (t) => t.contactId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$MeshPeersTableAnnotationComposer(
            $db: $db,
            $table: $db.meshPeers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$ContactsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ContactsTable,
          ContactEntity,
          $$ContactsTableFilterComposer,
          $$ContactsTableOrderingComposer,
          $$ContactsTableAnnotationComposer,
          $$ContactsTableCreateCompanionBuilder,
          $$ContactsTableUpdateCompanionBuilder,
          (ContactEntity, $$ContactsTableReferences),
          ContactEntity,
          PrefetchHooks Function({bool groupMembersRefs, bool meshPeersRefs})
        > {
  $$ContactsTableTableManager(_$AppDatabase db, $ContactsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ContactsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ContactsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ContactsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> displayName = const Value.absent(),
                Value<String?> avatar = const Value.absent(),
                Value<String> publicKey = const Value.absent(),
                Value<String> exchangePublicKey = const Value.absent(),
                Value<String> verificationStatus = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime?> lastSeen = const Value.absent(),
                Value<bool> isBlocked = const Value.absent(),
                Value<int?> lastMeshRssi = const Value.absent(),
                Value<DateTime?> lastMeshSeen = const Value.absent(),
                Value<int?> lastMeshHopCount = const Value.absent(),
                Value<String?> preferredTransport = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ContactsCompanion(
                id: id,
                displayName: displayName,
                avatar: avatar,
                publicKey: publicKey,
                exchangePublicKey: exchangePublicKey,
                verificationStatus: verificationStatus,
                createdAt: createdAt,
                lastSeen: lastSeen,
                isBlocked: isBlocked,
                lastMeshRssi: lastMeshRssi,
                lastMeshSeen: lastMeshSeen,
                lastMeshHopCount: lastMeshHopCount,
                preferredTransport: preferredTransport,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String displayName,
                Value<String?> avatar = const Value.absent(),
                required String publicKey,
                required String exchangePublicKey,
                Value<String> verificationStatus = const Value.absent(),
                required DateTime createdAt,
                Value<DateTime?> lastSeen = const Value.absent(),
                Value<bool> isBlocked = const Value.absent(),
                Value<int?> lastMeshRssi = const Value.absent(),
                Value<DateTime?> lastMeshSeen = const Value.absent(),
                Value<int?> lastMeshHopCount = const Value.absent(),
                Value<String?> preferredTransport = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ContactsCompanion.insert(
                id: id,
                displayName: displayName,
                avatar: avatar,
                publicKey: publicKey,
                exchangePublicKey: exchangePublicKey,
                verificationStatus: verificationStatus,
                createdAt: createdAt,
                lastSeen: lastSeen,
                isBlocked: isBlocked,
                lastMeshRssi: lastMeshRssi,
                lastMeshSeen: lastMeshSeen,
                lastMeshHopCount: lastMeshHopCount,
                preferredTransport: preferredTransport,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$ContactsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({groupMembersRefs = false, meshPeersRefs = false}) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (groupMembersRefs) db.groupMembers,
                    if (meshPeersRefs) db.meshPeers,
                  ],
                  addJoins: null,
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (groupMembersRefs)
                        await $_getPrefetchedData<
                          ContactEntity,
                          $ContactsTable,
                          GroupMemberEntity
                        >(
                          currentTable: table,
                          referencedTable: $$ContactsTableReferences
                              ._groupMembersRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$ContactsTableReferences(
                                db,
                                table,
                                p0,
                              ).groupMembersRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.contactId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (meshPeersRefs)
                        await $_getPrefetchedData<
                          ContactEntity,
                          $ContactsTable,
                          MeshPeerEntity
                        >(
                          currentTable: table,
                          referencedTable: $$ContactsTableReferences
                              ._meshPeersRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$ContactsTableReferences(
                                db,
                                table,
                                p0,
                              ).meshPeersRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.contactId == item.id,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$ContactsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ContactsTable,
      ContactEntity,
      $$ContactsTableFilterComposer,
      $$ContactsTableOrderingComposer,
      $$ContactsTableAnnotationComposer,
      $$ContactsTableCreateCompanionBuilder,
      $$ContactsTableUpdateCompanionBuilder,
      (ContactEntity, $$ContactsTableReferences),
      ContactEntity,
      PrefetchHooks Function({bool groupMembersRefs, bool meshPeersRefs})
    >;
typedef $$ConversationsTableCreateCompanionBuilder =
    ConversationsCompanion Function({
      required String id,
      required String type,
      Value<String?> name,
      Value<String?> avatar,
      required DateTime createdAt,
      Value<DateTime?> lastMessageAt,
      Value<int> unreadCount,
      Value<bool> isMuted,
      Value<bool> isArchived,
      Value<double?> centroidLatitude,
      Value<double?> centroidLongitude,
      Value<int?> channelRadiusMeters,
      Value<String?> geohash,
      Value<String?> creatorId,
      Value<int?> maxMessageAgeHours,
      Value<bool> isPublic,
      Value<int> participantCount,
      Value<int> rowid,
    });
typedef $$ConversationsTableUpdateCompanionBuilder =
    ConversationsCompanion Function({
      Value<String> id,
      Value<String> type,
      Value<String?> name,
      Value<String?> avatar,
      Value<DateTime> createdAt,
      Value<DateTime?> lastMessageAt,
      Value<int> unreadCount,
      Value<bool> isMuted,
      Value<bool> isArchived,
      Value<double?> centroidLatitude,
      Value<double?> centroidLongitude,
      Value<int?> channelRadiusMeters,
      Value<String?> geohash,
      Value<String?> creatorId,
      Value<int?> maxMessageAgeHours,
      Value<bool> isPublic,
      Value<int> participantCount,
      Value<int> rowid,
    });

final class $$ConversationsTableReferences
    extends
        BaseReferences<_$AppDatabase, $ConversationsTable, ConversationEntity> {
  $$ConversationsTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static MultiTypedResultKey<$MessagesTable, List<MessageEntity>>
  _messagesRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.messages,
    aliasName: $_aliasNameGenerator(
      db.conversations.id,
      db.messages.conversationId,
    ),
  );

  $$MessagesTableProcessedTableManager get messagesRefs {
    final manager = $$MessagesTableTableManager(
      $_db,
      $_db.messages,
    ).filter((f) => f.conversationId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_messagesRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$GroupMembersTable, List<GroupMemberEntity>>
  _groupMembersRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.groupMembers,
    aliasName: $_aliasNameGenerator(
      db.conversations.id,
      db.groupMembers.conversationId,
    ),
  );

  $$GroupMembersTableProcessedTableManager get groupMembersRefs {
    final manager = $$GroupMembersTableTableManager(
      $_db,
      $_db.groupMembers,
    ).filter((f) => f.conversationId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_groupMembersRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<
    $RallyChannelMembersTable,
    List<RallyChannelMemberEntity>
  >
  _rallyChannelMembersRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.rallyChannelMembers,
        aliasName: $_aliasNameGenerator(
          db.conversations.id,
          db.rallyChannelMembers.channelId,
        ),
      );

  $$RallyChannelMembersTableProcessedTableManager get rallyChannelMembersRefs {
    final manager = $$RallyChannelMembersTableTableManager(
      $_db,
      $_db.rallyChannelMembers,
    ).filter((f) => f.channelId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(
      _rallyChannelMembersRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$ConversationsTableFilterComposer
    extends Composer<_$AppDatabase, $ConversationsTable> {
  $$ConversationsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get type => $composableBuilder(
    column: $table.type,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get avatar => $composableBuilder(
    column: $table.avatar,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastMessageAt => $composableBuilder(
    column: $table.lastMessageAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get unreadCount => $composableBuilder(
    column: $table.unreadCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isMuted => $composableBuilder(
    column: $table.isMuted,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isArchived => $composableBuilder(
    column: $table.isArchived,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get centroidLatitude => $composableBuilder(
    column: $table.centroidLatitude,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get centroidLongitude => $composableBuilder(
    column: $table.centroidLongitude,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get channelRadiusMeters => $composableBuilder(
    column: $table.channelRadiusMeters,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get geohash => $composableBuilder(
    column: $table.geohash,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get creatorId => $composableBuilder(
    column: $table.creatorId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get maxMessageAgeHours => $composableBuilder(
    column: $table.maxMessageAgeHours,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isPublic => $composableBuilder(
    column: $table.isPublic,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get participantCount => $composableBuilder(
    column: $table.participantCount,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> messagesRefs(
    Expression<bool> Function($$MessagesTableFilterComposer f) f,
  ) {
    final $$MessagesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.messages,
      getReferencedColumn: (t) => t.conversationId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$MessagesTableFilterComposer(
            $db: $db,
            $table: $db.messages,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> groupMembersRefs(
    Expression<bool> Function($$GroupMembersTableFilterComposer f) f,
  ) {
    final $$GroupMembersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.groupMembers,
      getReferencedColumn: (t) => t.conversationId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$GroupMembersTableFilterComposer(
            $db: $db,
            $table: $db.groupMembers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> rallyChannelMembersRefs(
    Expression<bool> Function($$RallyChannelMembersTableFilterComposer f) f,
  ) {
    final $$RallyChannelMembersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.rallyChannelMembers,
      getReferencedColumn: (t) => t.channelId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$RallyChannelMembersTableFilterComposer(
            $db: $db,
            $table: $db.rallyChannelMembers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$ConversationsTableOrderingComposer
    extends Composer<_$AppDatabase, $ConversationsTable> {
  $$ConversationsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get type => $composableBuilder(
    column: $table.type,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get avatar => $composableBuilder(
    column: $table.avatar,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastMessageAt => $composableBuilder(
    column: $table.lastMessageAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get unreadCount => $composableBuilder(
    column: $table.unreadCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isMuted => $composableBuilder(
    column: $table.isMuted,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isArchived => $composableBuilder(
    column: $table.isArchived,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get centroidLatitude => $composableBuilder(
    column: $table.centroidLatitude,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get centroidLongitude => $composableBuilder(
    column: $table.centroidLongitude,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get channelRadiusMeters => $composableBuilder(
    column: $table.channelRadiusMeters,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get geohash => $composableBuilder(
    column: $table.geohash,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get creatorId => $composableBuilder(
    column: $table.creatorId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get maxMessageAgeHours => $composableBuilder(
    column: $table.maxMessageAgeHours,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isPublic => $composableBuilder(
    column: $table.isPublic,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get participantCount => $composableBuilder(
    column: $table.participantCount,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$ConversationsTableAnnotationComposer
    extends Composer<_$AppDatabase, $ConversationsTable> {
  $$ConversationsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get type =>
      $composableBuilder(column: $table.type, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get avatar =>
      $composableBuilder(column: $table.avatar, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get lastMessageAt => $composableBuilder(
    column: $table.lastMessageAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get unreadCount => $composableBuilder(
    column: $table.unreadCount,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isMuted =>
      $composableBuilder(column: $table.isMuted, builder: (column) => column);

  GeneratedColumn<bool> get isArchived => $composableBuilder(
    column: $table.isArchived,
    builder: (column) => column,
  );

  GeneratedColumn<double> get centroidLatitude => $composableBuilder(
    column: $table.centroidLatitude,
    builder: (column) => column,
  );

  GeneratedColumn<double> get centroidLongitude => $composableBuilder(
    column: $table.centroidLongitude,
    builder: (column) => column,
  );

  GeneratedColumn<int> get channelRadiusMeters => $composableBuilder(
    column: $table.channelRadiusMeters,
    builder: (column) => column,
  );

  GeneratedColumn<String> get geohash =>
      $composableBuilder(column: $table.geohash, builder: (column) => column);

  GeneratedColumn<String> get creatorId =>
      $composableBuilder(column: $table.creatorId, builder: (column) => column);

  GeneratedColumn<int> get maxMessageAgeHours => $composableBuilder(
    column: $table.maxMessageAgeHours,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isPublic =>
      $composableBuilder(column: $table.isPublic, builder: (column) => column);

  GeneratedColumn<int> get participantCount => $composableBuilder(
    column: $table.participantCount,
    builder: (column) => column,
  );

  Expression<T> messagesRefs<T extends Object>(
    Expression<T> Function($$MessagesTableAnnotationComposer a) f,
  ) {
    final $$MessagesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.messages,
      getReferencedColumn: (t) => t.conversationId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$MessagesTableAnnotationComposer(
            $db: $db,
            $table: $db.messages,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> groupMembersRefs<T extends Object>(
    Expression<T> Function($$GroupMembersTableAnnotationComposer a) f,
  ) {
    final $$GroupMembersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.groupMembers,
      getReferencedColumn: (t) => t.conversationId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$GroupMembersTableAnnotationComposer(
            $db: $db,
            $table: $db.groupMembers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> rallyChannelMembersRefs<T extends Object>(
    Expression<T> Function($$RallyChannelMembersTableAnnotationComposer a) f,
  ) {
    final $$RallyChannelMembersTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.id,
          referencedTable: $db.rallyChannelMembers,
          getReferencedColumn: (t) => t.channelId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$RallyChannelMembersTableAnnotationComposer(
                $db: $db,
                $table: $db.rallyChannelMembers,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }
}

class $$ConversationsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ConversationsTable,
          ConversationEntity,
          $$ConversationsTableFilterComposer,
          $$ConversationsTableOrderingComposer,
          $$ConversationsTableAnnotationComposer,
          $$ConversationsTableCreateCompanionBuilder,
          $$ConversationsTableUpdateCompanionBuilder,
          (ConversationEntity, $$ConversationsTableReferences),
          ConversationEntity,
          PrefetchHooks Function({
            bool messagesRefs,
            bool groupMembersRefs,
            bool rallyChannelMembersRefs,
          })
        > {
  $$ConversationsTableTableManager(_$AppDatabase db, $ConversationsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ConversationsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ConversationsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ConversationsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> type = const Value.absent(),
                Value<String?> name = const Value.absent(),
                Value<String?> avatar = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime?> lastMessageAt = const Value.absent(),
                Value<int> unreadCount = const Value.absent(),
                Value<bool> isMuted = const Value.absent(),
                Value<bool> isArchived = const Value.absent(),
                Value<double?> centroidLatitude = const Value.absent(),
                Value<double?> centroidLongitude = const Value.absent(),
                Value<int?> channelRadiusMeters = const Value.absent(),
                Value<String?> geohash = const Value.absent(),
                Value<String?> creatorId = const Value.absent(),
                Value<int?> maxMessageAgeHours = const Value.absent(),
                Value<bool> isPublic = const Value.absent(),
                Value<int> participantCount = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ConversationsCompanion(
                id: id,
                type: type,
                name: name,
                avatar: avatar,
                createdAt: createdAt,
                lastMessageAt: lastMessageAt,
                unreadCount: unreadCount,
                isMuted: isMuted,
                isArchived: isArchived,
                centroidLatitude: centroidLatitude,
                centroidLongitude: centroidLongitude,
                channelRadiusMeters: channelRadiusMeters,
                geohash: geohash,
                creatorId: creatorId,
                maxMessageAgeHours: maxMessageAgeHours,
                isPublic: isPublic,
                participantCount: participantCount,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String type,
                Value<String?> name = const Value.absent(),
                Value<String?> avatar = const Value.absent(),
                required DateTime createdAt,
                Value<DateTime?> lastMessageAt = const Value.absent(),
                Value<int> unreadCount = const Value.absent(),
                Value<bool> isMuted = const Value.absent(),
                Value<bool> isArchived = const Value.absent(),
                Value<double?> centroidLatitude = const Value.absent(),
                Value<double?> centroidLongitude = const Value.absent(),
                Value<int?> channelRadiusMeters = const Value.absent(),
                Value<String?> geohash = const Value.absent(),
                Value<String?> creatorId = const Value.absent(),
                Value<int?> maxMessageAgeHours = const Value.absent(),
                Value<bool> isPublic = const Value.absent(),
                Value<int> participantCount = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ConversationsCompanion.insert(
                id: id,
                type: type,
                name: name,
                avatar: avatar,
                createdAt: createdAt,
                lastMessageAt: lastMessageAt,
                unreadCount: unreadCount,
                isMuted: isMuted,
                isArchived: isArchived,
                centroidLatitude: centroidLatitude,
                centroidLongitude: centroidLongitude,
                channelRadiusMeters: channelRadiusMeters,
                geohash: geohash,
                creatorId: creatorId,
                maxMessageAgeHours: maxMessageAgeHours,
                isPublic: isPublic,
                participantCount: participantCount,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$ConversationsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({
                messagesRefs = false,
                groupMembersRefs = false,
                rallyChannelMembersRefs = false,
              }) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (messagesRefs) db.messages,
                    if (groupMembersRefs) db.groupMembers,
                    if (rallyChannelMembersRefs) db.rallyChannelMembers,
                  ],
                  addJoins: null,
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (messagesRefs)
                        await $_getPrefetchedData<
                          ConversationEntity,
                          $ConversationsTable,
                          MessageEntity
                        >(
                          currentTable: table,
                          referencedTable: $$ConversationsTableReferences
                              ._messagesRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$ConversationsTableReferences(
                                db,
                                table,
                                p0,
                              ).messagesRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.conversationId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (groupMembersRefs)
                        await $_getPrefetchedData<
                          ConversationEntity,
                          $ConversationsTable,
                          GroupMemberEntity
                        >(
                          currentTable: table,
                          referencedTable: $$ConversationsTableReferences
                              ._groupMembersRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$ConversationsTableReferences(
                                db,
                                table,
                                p0,
                              ).groupMembersRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.conversationId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (rallyChannelMembersRefs)
                        await $_getPrefetchedData<
                          ConversationEntity,
                          $ConversationsTable,
                          RallyChannelMemberEntity
                        >(
                          currentTable: table,
                          referencedTable: $$ConversationsTableReferences
                              ._rallyChannelMembersRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$ConversationsTableReferences(
                                db,
                                table,
                                p0,
                              ).rallyChannelMembersRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.channelId == item.id,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$ConversationsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ConversationsTable,
      ConversationEntity,
      $$ConversationsTableFilterComposer,
      $$ConversationsTableOrderingComposer,
      $$ConversationsTableAnnotationComposer,
      $$ConversationsTableCreateCompanionBuilder,
      $$ConversationsTableUpdateCompanionBuilder,
      (ConversationEntity, $$ConversationsTableReferences),
      ConversationEntity,
      PrefetchHooks Function({
        bool messagesRefs,
        bool groupMembersRefs,
        bool rallyChannelMembersRefs,
      })
    >;
typedef $$MessagesTableCreateCompanionBuilder =
    MessagesCompanion Function({
      required String id,
      required String conversationId,
      required String senderId,
      required String content,
      Value<String> type,
      Value<String> status,
      Value<String?> transport,
      required DateTime timestamp,
      Value<DateTime?> deliveredAt,
      Value<DateTime?> readAt,
      required bool isFromMe,
      Value<String?> replyToId,
      Value<String?> metadata,
      Value<int> rowid,
    });
typedef $$MessagesTableUpdateCompanionBuilder =
    MessagesCompanion Function({
      Value<String> id,
      Value<String> conversationId,
      Value<String> senderId,
      Value<String> content,
      Value<String> type,
      Value<String> status,
      Value<String?> transport,
      Value<DateTime> timestamp,
      Value<DateTime?> deliveredAt,
      Value<DateTime?> readAt,
      Value<bool> isFromMe,
      Value<String?> replyToId,
      Value<String?> metadata,
      Value<int> rowid,
    });

final class $$MessagesTableReferences
    extends BaseReferences<_$AppDatabase, $MessagesTable, MessageEntity> {
  $$MessagesTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $ConversationsTable _conversationIdTable(_$AppDatabase db) =>
      db.conversations.createAlias(
        $_aliasNameGenerator(db.messages.conversationId, db.conversations.id),
      );

  $$ConversationsTableProcessedTableManager get conversationId {
    final $_column = $_itemColumn<String>('conversation_id')!;

    final manager = $$ConversationsTableTableManager(
      $_db,
      $_db.conversations,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_conversationIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$MessagesTableFilterComposer
    extends Composer<_$AppDatabase, $MessagesTable> {
  $$MessagesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get senderId => $composableBuilder(
    column: $table.senderId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get content => $composableBuilder(
    column: $table.content,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get type => $composableBuilder(
    column: $table.type,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get transport => $composableBuilder(
    column: $table.transport,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get timestamp => $composableBuilder(
    column: $table.timestamp,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get deliveredAt => $composableBuilder(
    column: $table.deliveredAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get readAt => $composableBuilder(
    column: $table.readAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isFromMe => $composableBuilder(
    column: $table.isFromMe,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get replyToId => $composableBuilder(
    column: $table.replyToId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get metadata => $composableBuilder(
    column: $table.metadata,
    builder: (column) => ColumnFilters(column),
  );

  $$ConversationsTableFilterComposer get conversationId {
    final $$ConversationsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.conversationId,
      referencedTable: $db.conversations,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ConversationsTableFilterComposer(
            $db: $db,
            $table: $db.conversations,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$MessagesTableOrderingComposer
    extends Composer<_$AppDatabase, $MessagesTable> {
  $$MessagesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get senderId => $composableBuilder(
    column: $table.senderId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get content => $composableBuilder(
    column: $table.content,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get type => $composableBuilder(
    column: $table.type,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get transport => $composableBuilder(
    column: $table.transport,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get timestamp => $composableBuilder(
    column: $table.timestamp,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get deliveredAt => $composableBuilder(
    column: $table.deliveredAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get readAt => $composableBuilder(
    column: $table.readAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isFromMe => $composableBuilder(
    column: $table.isFromMe,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get replyToId => $composableBuilder(
    column: $table.replyToId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get metadata => $composableBuilder(
    column: $table.metadata,
    builder: (column) => ColumnOrderings(column),
  );

  $$ConversationsTableOrderingComposer get conversationId {
    final $$ConversationsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.conversationId,
      referencedTable: $db.conversations,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ConversationsTableOrderingComposer(
            $db: $db,
            $table: $db.conversations,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$MessagesTableAnnotationComposer
    extends Composer<_$AppDatabase, $MessagesTable> {
  $$MessagesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get senderId =>
      $composableBuilder(column: $table.senderId, builder: (column) => column);

  GeneratedColumn<String> get content =>
      $composableBuilder(column: $table.content, builder: (column) => column);

  GeneratedColumn<String> get type =>
      $composableBuilder(column: $table.type, builder: (column) => column);

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<String> get transport =>
      $composableBuilder(column: $table.transport, builder: (column) => column);

  GeneratedColumn<DateTime> get timestamp =>
      $composableBuilder(column: $table.timestamp, builder: (column) => column);

  GeneratedColumn<DateTime> get deliveredAt => $composableBuilder(
    column: $table.deliveredAt,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get readAt =>
      $composableBuilder(column: $table.readAt, builder: (column) => column);

  GeneratedColumn<bool> get isFromMe =>
      $composableBuilder(column: $table.isFromMe, builder: (column) => column);

  GeneratedColumn<String> get replyToId =>
      $composableBuilder(column: $table.replyToId, builder: (column) => column);

  GeneratedColumn<String> get metadata =>
      $composableBuilder(column: $table.metadata, builder: (column) => column);

  $$ConversationsTableAnnotationComposer get conversationId {
    final $$ConversationsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.conversationId,
      referencedTable: $db.conversations,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ConversationsTableAnnotationComposer(
            $db: $db,
            $table: $db.conversations,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$MessagesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $MessagesTable,
          MessageEntity,
          $$MessagesTableFilterComposer,
          $$MessagesTableOrderingComposer,
          $$MessagesTableAnnotationComposer,
          $$MessagesTableCreateCompanionBuilder,
          $$MessagesTableUpdateCompanionBuilder,
          (MessageEntity, $$MessagesTableReferences),
          MessageEntity,
          PrefetchHooks Function({bool conversationId})
        > {
  $$MessagesTableTableManager(_$AppDatabase db, $MessagesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$MessagesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$MessagesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$MessagesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> conversationId = const Value.absent(),
                Value<String> senderId = const Value.absent(),
                Value<String> content = const Value.absent(),
                Value<String> type = const Value.absent(),
                Value<String> status = const Value.absent(),
                Value<String?> transport = const Value.absent(),
                Value<DateTime> timestamp = const Value.absent(),
                Value<DateTime?> deliveredAt = const Value.absent(),
                Value<DateTime?> readAt = const Value.absent(),
                Value<bool> isFromMe = const Value.absent(),
                Value<String?> replyToId = const Value.absent(),
                Value<String?> metadata = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => MessagesCompanion(
                id: id,
                conversationId: conversationId,
                senderId: senderId,
                content: content,
                type: type,
                status: status,
                transport: transport,
                timestamp: timestamp,
                deliveredAt: deliveredAt,
                readAt: readAt,
                isFromMe: isFromMe,
                replyToId: replyToId,
                metadata: metadata,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String conversationId,
                required String senderId,
                required String content,
                Value<String> type = const Value.absent(),
                Value<String> status = const Value.absent(),
                Value<String?> transport = const Value.absent(),
                required DateTime timestamp,
                Value<DateTime?> deliveredAt = const Value.absent(),
                Value<DateTime?> readAt = const Value.absent(),
                required bool isFromMe,
                Value<String?> replyToId = const Value.absent(),
                Value<String?> metadata = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => MessagesCompanion.insert(
                id: id,
                conversationId: conversationId,
                senderId: senderId,
                content: content,
                type: type,
                status: status,
                transport: transport,
                timestamp: timestamp,
                deliveredAt: deliveredAt,
                readAt: readAt,
                isFromMe: isFromMe,
                replyToId: replyToId,
                metadata: metadata,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$MessagesTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({conversationId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (conversationId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.conversationId,
                                referencedTable: $$MessagesTableReferences
                                    ._conversationIdTable(db),
                                referencedColumn: $$MessagesTableReferences
                                    ._conversationIdTable(db)
                                    .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$MessagesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $MessagesTable,
      MessageEntity,
      $$MessagesTableFilterComposer,
      $$MessagesTableOrderingComposer,
      $$MessagesTableAnnotationComposer,
      $$MessagesTableCreateCompanionBuilder,
      $$MessagesTableUpdateCompanionBuilder,
      (MessageEntity, $$MessagesTableReferences),
      MessageEntity,
      PrefetchHooks Function({bool conversationId})
    >;
typedef $$GroupMembersTableCreateCompanionBuilder =
    GroupMembersCompanion Function({
      Value<int> id,
      required String conversationId,
      required String contactId,
      Value<String> role,
      required DateTime joinedAt,
    });
typedef $$GroupMembersTableUpdateCompanionBuilder =
    GroupMembersCompanion Function({
      Value<int> id,
      Value<String> conversationId,
      Value<String> contactId,
      Value<String> role,
      Value<DateTime> joinedAt,
    });

final class $$GroupMembersTableReferences
    extends
        BaseReferences<_$AppDatabase, $GroupMembersTable, GroupMemberEntity> {
  $$GroupMembersTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $ConversationsTable _conversationIdTable(_$AppDatabase db) =>
      db.conversations.createAlias(
        $_aliasNameGenerator(
          db.groupMembers.conversationId,
          db.conversations.id,
        ),
      );

  $$ConversationsTableProcessedTableManager get conversationId {
    final $_column = $_itemColumn<String>('conversation_id')!;

    final manager = $$ConversationsTableTableManager(
      $_db,
      $_db.conversations,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_conversationIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $ContactsTable _contactIdTable(_$AppDatabase db) =>
      db.contacts.createAlias(
        $_aliasNameGenerator(db.groupMembers.contactId, db.contacts.id),
      );

  $$ContactsTableProcessedTableManager get contactId {
    final $_column = $_itemColumn<String>('contact_id')!;

    final manager = $$ContactsTableTableManager(
      $_db,
      $_db.contacts,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_contactIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$GroupMembersTableFilterComposer
    extends Composer<_$AppDatabase, $GroupMembersTable> {
  $$GroupMembersTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get role => $composableBuilder(
    column: $table.role,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get joinedAt => $composableBuilder(
    column: $table.joinedAt,
    builder: (column) => ColumnFilters(column),
  );

  $$ConversationsTableFilterComposer get conversationId {
    final $$ConversationsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.conversationId,
      referencedTable: $db.conversations,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ConversationsTableFilterComposer(
            $db: $db,
            $table: $db.conversations,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ContactsTableFilterComposer get contactId {
    final $$ContactsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.contactId,
      referencedTable: $db.contacts,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ContactsTableFilterComposer(
            $db: $db,
            $table: $db.contacts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$GroupMembersTableOrderingComposer
    extends Composer<_$AppDatabase, $GroupMembersTable> {
  $$GroupMembersTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get role => $composableBuilder(
    column: $table.role,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get joinedAt => $composableBuilder(
    column: $table.joinedAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$ConversationsTableOrderingComposer get conversationId {
    final $$ConversationsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.conversationId,
      referencedTable: $db.conversations,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ConversationsTableOrderingComposer(
            $db: $db,
            $table: $db.conversations,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ContactsTableOrderingComposer get contactId {
    final $$ContactsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.contactId,
      referencedTable: $db.contacts,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ContactsTableOrderingComposer(
            $db: $db,
            $table: $db.contacts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$GroupMembersTableAnnotationComposer
    extends Composer<_$AppDatabase, $GroupMembersTable> {
  $$GroupMembersTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get role =>
      $composableBuilder(column: $table.role, builder: (column) => column);

  GeneratedColumn<DateTime> get joinedAt =>
      $composableBuilder(column: $table.joinedAt, builder: (column) => column);

  $$ConversationsTableAnnotationComposer get conversationId {
    final $$ConversationsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.conversationId,
      referencedTable: $db.conversations,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ConversationsTableAnnotationComposer(
            $db: $db,
            $table: $db.conversations,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ContactsTableAnnotationComposer get contactId {
    final $$ContactsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.contactId,
      referencedTable: $db.contacts,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ContactsTableAnnotationComposer(
            $db: $db,
            $table: $db.contacts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$GroupMembersTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $GroupMembersTable,
          GroupMemberEntity,
          $$GroupMembersTableFilterComposer,
          $$GroupMembersTableOrderingComposer,
          $$GroupMembersTableAnnotationComposer,
          $$GroupMembersTableCreateCompanionBuilder,
          $$GroupMembersTableUpdateCompanionBuilder,
          (GroupMemberEntity, $$GroupMembersTableReferences),
          GroupMemberEntity,
          PrefetchHooks Function({bool conversationId, bool contactId})
        > {
  $$GroupMembersTableTableManager(_$AppDatabase db, $GroupMembersTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$GroupMembersTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$GroupMembersTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$GroupMembersTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                Value<String> conversationId = const Value.absent(),
                Value<String> contactId = const Value.absent(),
                Value<String> role = const Value.absent(),
                Value<DateTime> joinedAt = const Value.absent(),
              }) => GroupMembersCompanion(
                id: id,
                conversationId: conversationId,
                contactId: contactId,
                role: role,
                joinedAt: joinedAt,
              ),
          createCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                required String conversationId,
                required String contactId,
                Value<String> role = const Value.absent(),
                required DateTime joinedAt,
              }) => GroupMembersCompanion.insert(
                id: id,
                conversationId: conversationId,
                contactId: contactId,
                role: role,
                joinedAt: joinedAt,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$GroupMembersTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({conversationId = false, contactId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (conversationId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.conversationId,
                                referencedTable: $$GroupMembersTableReferences
                                    ._conversationIdTable(db),
                                referencedColumn: $$GroupMembersTableReferences
                                    ._conversationIdTable(db)
                                    .id,
                              )
                              as T;
                    }
                    if (contactId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.contactId,
                                referencedTable: $$GroupMembersTableReferences
                                    ._contactIdTable(db),
                                referencedColumn: $$GroupMembersTableReferences
                                    ._contactIdTable(db)
                                    .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$GroupMembersTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $GroupMembersTable,
      GroupMemberEntity,
      $$GroupMembersTableFilterComposer,
      $$GroupMembersTableOrderingComposer,
      $$GroupMembersTableAnnotationComposer,
      $$GroupMembersTableCreateCompanionBuilder,
      $$GroupMembersTableUpdateCompanionBuilder,
      (GroupMemberEntity, $$GroupMembersTableReferences),
      GroupMemberEntity,
      PrefetchHooks Function({bool conversationId, bool contactId})
    >;
typedef $$MeshPeersTableCreateCompanionBuilder =
    MeshPeersCompanion Function({
      required String meshPeerId,
      required String publicKey,
      required String exchangePublicKey,
      Value<String?> displayName,
      required int rssi,
      Value<String> connectionState,
      required DateTime lastSeen,
      required DateTime firstSeen,
      Value<String?> noiseSessionState,
      Value<String?> noiseTransportState,
      Value<bool> isContact,
      Value<String?> contactId,
      Value<int> rowid,
    });
typedef $$MeshPeersTableUpdateCompanionBuilder =
    MeshPeersCompanion Function({
      Value<String> meshPeerId,
      Value<String> publicKey,
      Value<String> exchangePublicKey,
      Value<String?> displayName,
      Value<int> rssi,
      Value<String> connectionState,
      Value<DateTime> lastSeen,
      Value<DateTime> firstSeen,
      Value<String?> noiseSessionState,
      Value<String?> noiseTransportState,
      Value<bool> isContact,
      Value<String?> contactId,
      Value<int> rowid,
    });

final class $$MeshPeersTableReferences
    extends BaseReferences<_$AppDatabase, $MeshPeersTable, MeshPeerEntity> {
  $$MeshPeersTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $ContactsTable _contactIdTable(_$AppDatabase db) =>
      db.contacts.createAlias(
        $_aliasNameGenerator(db.meshPeers.contactId, db.contacts.id),
      );

  $$ContactsTableProcessedTableManager? get contactId {
    final $_column = $_itemColumn<String>('contact_id');
    if ($_column == null) return null;
    final manager = $$ContactsTableTableManager(
      $_db,
      $_db.contacts,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_contactIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$MeshPeersTableFilterComposer
    extends Composer<_$AppDatabase, $MeshPeersTable> {
  $$MeshPeersTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get meshPeerId => $composableBuilder(
    column: $table.meshPeerId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get publicKey => $composableBuilder(
    column: $table.publicKey,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get exchangePublicKey => $composableBuilder(
    column: $table.exchangePublicKey,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get displayName => $composableBuilder(
    column: $table.displayName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get rssi => $composableBuilder(
    column: $table.rssi,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get connectionState => $composableBuilder(
    column: $table.connectionState,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastSeen => $composableBuilder(
    column: $table.lastSeen,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get firstSeen => $composableBuilder(
    column: $table.firstSeen,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get noiseSessionState => $composableBuilder(
    column: $table.noiseSessionState,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get noiseTransportState => $composableBuilder(
    column: $table.noiseTransportState,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isContact => $composableBuilder(
    column: $table.isContact,
    builder: (column) => ColumnFilters(column),
  );

  $$ContactsTableFilterComposer get contactId {
    final $$ContactsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.contactId,
      referencedTable: $db.contacts,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ContactsTableFilterComposer(
            $db: $db,
            $table: $db.contacts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$MeshPeersTableOrderingComposer
    extends Composer<_$AppDatabase, $MeshPeersTable> {
  $$MeshPeersTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get meshPeerId => $composableBuilder(
    column: $table.meshPeerId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get publicKey => $composableBuilder(
    column: $table.publicKey,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get exchangePublicKey => $composableBuilder(
    column: $table.exchangePublicKey,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get displayName => $composableBuilder(
    column: $table.displayName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get rssi => $composableBuilder(
    column: $table.rssi,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get connectionState => $composableBuilder(
    column: $table.connectionState,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastSeen => $composableBuilder(
    column: $table.lastSeen,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get firstSeen => $composableBuilder(
    column: $table.firstSeen,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get noiseSessionState => $composableBuilder(
    column: $table.noiseSessionState,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get noiseTransportState => $composableBuilder(
    column: $table.noiseTransportState,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isContact => $composableBuilder(
    column: $table.isContact,
    builder: (column) => ColumnOrderings(column),
  );

  $$ContactsTableOrderingComposer get contactId {
    final $$ContactsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.contactId,
      referencedTable: $db.contacts,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ContactsTableOrderingComposer(
            $db: $db,
            $table: $db.contacts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$MeshPeersTableAnnotationComposer
    extends Composer<_$AppDatabase, $MeshPeersTable> {
  $$MeshPeersTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get meshPeerId => $composableBuilder(
    column: $table.meshPeerId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get publicKey =>
      $composableBuilder(column: $table.publicKey, builder: (column) => column);

  GeneratedColumn<String> get exchangePublicKey => $composableBuilder(
    column: $table.exchangePublicKey,
    builder: (column) => column,
  );

  GeneratedColumn<String> get displayName => $composableBuilder(
    column: $table.displayName,
    builder: (column) => column,
  );

  GeneratedColumn<int> get rssi =>
      $composableBuilder(column: $table.rssi, builder: (column) => column);

  GeneratedColumn<String> get connectionState => $composableBuilder(
    column: $table.connectionState,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get lastSeen =>
      $composableBuilder(column: $table.lastSeen, builder: (column) => column);

  GeneratedColumn<DateTime> get firstSeen =>
      $composableBuilder(column: $table.firstSeen, builder: (column) => column);

  GeneratedColumn<String> get noiseSessionState => $composableBuilder(
    column: $table.noiseSessionState,
    builder: (column) => column,
  );

  GeneratedColumn<String> get noiseTransportState => $composableBuilder(
    column: $table.noiseTransportState,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isContact =>
      $composableBuilder(column: $table.isContact, builder: (column) => column);

  $$ContactsTableAnnotationComposer get contactId {
    final $$ContactsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.contactId,
      referencedTable: $db.contacts,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ContactsTableAnnotationComposer(
            $db: $db,
            $table: $db.contacts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$MeshPeersTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $MeshPeersTable,
          MeshPeerEntity,
          $$MeshPeersTableFilterComposer,
          $$MeshPeersTableOrderingComposer,
          $$MeshPeersTableAnnotationComposer,
          $$MeshPeersTableCreateCompanionBuilder,
          $$MeshPeersTableUpdateCompanionBuilder,
          (MeshPeerEntity, $$MeshPeersTableReferences),
          MeshPeerEntity,
          PrefetchHooks Function({bool contactId})
        > {
  $$MeshPeersTableTableManager(_$AppDatabase db, $MeshPeersTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$MeshPeersTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$MeshPeersTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$MeshPeersTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> meshPeerId = const Value.absent(),
                Value<String> publicKey = const Value.absent(),
                Value<String> exchangePublicKey = const Value.absent(),
                Value<String?> displayName = const Value.absent(),
                Value<int> rssi = const Value.absent(),
                Value<String> connectionState = const Value.absent(),
                Value<DateTime> lastSeen = const Value.absent(),
                Value<DateTime> firstSeen = const Value.absent(),
                Value<String?> noiseSessionState = const Value.absent(),
                Value<String?> noiseTransportState = const Value.absent(),
                Value<bool> isContact = const Value.absent(),
                Value<String?> contactId = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => MeshPeersCompanion(
                meshPeerId: meshPeerId,
                publicKey: publicKey,
                exchangePublicKey: exchangePublicKey,
                displayName: displayName,
                rssi: rssi,
                connectionState: connectionState,
                lastSeen: lastSeen,
                firstSeen: firstSeen,
                noiseSessionState: noiseSessionState,
                noiseTransportState: noiseTransportState,
                isContact: isContact,
                contactId: contactId,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String meshPeerId,
                required String publicKey,
                required String exchangePublicKey,
                Value<String?> displayName = const Value.absent(),
                required int rssi,
                Value<String> connectionState = const Value.absent(),
                required DateTime lastSeen,
                required DateTime firstSeen,
                Value<String?> noiseSessionState = const Value.absent(),
                Value<String?> noiseTransportState = const Value.absent(),
                Value<bool> isContact = const Value.absent(),
                Value<String?> contactId = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => MeshPeersCompanion.insert(
                meshPeerId: meshPeerId,
                publicKey: publicKey,
                exchangePublicKey: exchangePublicKey,
                displayName: displayName,
                rssi: rssi,
                connectionState: connectionState,
                lastSeen: lastSeen,
                firstSeen: firstSeen,
                noiseSessionState: noiseSessionState,
                noiseTransportState: noiseTransportState,
                isContact: isContact,
                contactId: contactId,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$MeshPeersTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({contactId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (contactId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.contactId,
                                referencedTable: $$MeshPeersTableReferences
                                    ._contactIdTable(db),
                                referencedColumn: $$MeshPeersTableReferences
                                    ._contactIdTable(db)
                                    .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$MeshPeersTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $MeshPeersTable,
      MeshPeerEntity,
      $$MeshPeersTableFilterComposer,
      $$MeshPeersTableOrderingComposer,
      $$MeshPeersTableAnnotationComposer,
      $$MeshPeersTableCreateCompanionBuilder,
      $$MeshPeersTableUpdateCompanionBuilder,
      (MeshPeerEntity, $$MeshPeersTableReferences),
      MeshPeerEntity,
      PrefetchHooks Function({bool contactId})
    >;
typedef $$MeshRoutesTableCreateCompanionBuilder =
    MeshRoutesCompanion Function({
      Value<int> id,
      required String destinationPeerId,
      required String nextHopPeerId,
      required int hopCount,
      Value<double> qualityScore,
      required DateTime lastUsed,
      required DateTime discoveredAt,
      required DateTime expiresAt,
    });
typedef $$MeshRoutesTableUpdateCompanionBuilder =
    MeshRoutesCompanion Function({
      Value<int> id,
      Value<String> destinationPeerId,
      Value<String> nextHopPeerId,
      Value<int> hopCount,
      Value<double> qualityScore,
      Value<DateTime> lastUsed,
      Value<DateTime> discoveredAt,
      Value<DateTime> expiresAt,
    });

class $$MeshRoutesTableFilterComposer
    extends Composer<_$AppDatabase, $MeshRoutesTable> {
  $$MeshRoutesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get destinationPeerId => $composableBuilder(
    column: $table.destinationPeerId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get nextHopPeerId => $composableBuilder(
    column: $table.nextHopPeerId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get hopCount => $composableBuilder(
    column: $table.hopCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get qualityScore => $composableBuilder(
    column: $table.qualityScore,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastUsed => $composableBuilder(
    column: $table.lastUsed,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get discoveredAt => $composableBuilder(
    column: $table.discoveredAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get expiresAt => $composableBuilder(
    column: $table.expiresAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$MeshRoutesTableOrderingComposer
    extends Composer<_$AppDatabase, $MeshRoutesTable> {
  $$MeshRoutesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get destinationPeerId => $composableBuilder(
    column: $table.destinationPeerId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get nextHopPeerId => $composableBuilder(
    column: $table.nextHopPeerId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get hopCount => $composableBuilder(
    column: $table.hopCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get qualityScore => $composableBuilder(
    column: $table.qualityScore,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastUsed => $composableBuilder(
    column: $table.lastUsed,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get discoveredAt => $composableBuilder(
    column: $table.discoveredAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get expiresAt => $composableBuilder(
    column: $table.expiresAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$MeshRoutesTableAnnotationComposer
    extends Composer<_$AppDatabase, $MeshRoutesTable> {
  $$MeshRoutesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get destinationPeerId => $composableBuilder(
    column: $table.destinationPeerId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get nextHopPeerId => $composableBuilder(
    column: $table.nextHopPeerId,
    builder: (column) => column,
  );

  GeneratedColumn<int> get hopCount =>
      $composableBuilder(column: $table.hopCount, builder: (column) => column);

  GeneratedColumn<double> get qualityScore => $composableBuilder(
    column: $table.qualityScore,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get lastUsed =>
      $composableBuilder(column: $table.lastUsed, builder: (column) => column);

  GeneratedColumn<DateTime> get discoveredAt => $composableBuilder(
    column: $table.discoveredAt,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get expiresAt =>
      $composableBuilder(column: $table.expiresAt, builder: (column) => column);
}

class $$MeshRoutesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $MeshRoutesTable,
          MeshRouteEntity,
          $$MeshRoutesTableFilterComposer,
          $$MeshRoutesTableOrderingComposer,
          $$MeshRoutesTableAnnotationComposer,
          $$MeshRoutesTableCreateCompanionBuilder,
          $$MeshRoutesTableUpdateCompanionBuilder,
          (
            MeshRouteEntity,
            BaseReferences<_$AppDatabase, $MeshRoutesTable, MeshRouteEntity>,
          ),
          MeshRouteEntity,
          PrefetchHooks Function()
        > {
  $$MeshRoutesTableTableManager(_$AppDatabase db, $MeshRoutesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$MeshRoutesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$MeshRoutesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$MeshRoutesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                Value<String> destinationPeerId = const Value.absent(),
                Value<String> nextHopPeerId = const Value.absent(),
                Value<int> hopCount = const Value.absent(),
                Value<double> qualityScore = const Value.absent(),
                Value<DateTime> lastUsed = const Value.absent(),
                Value<DateTime> discoveredAt = const Value.absent(),
                Value<DateTime> expiresAt = const Value.absent(),
              }) => MeshRoutesCompanion(
                id: id,
                destinationPeerId: destinationPeerId,
                nextHopPeerId: nextHopPeerId,
                hopCount: hopCount,
                qualityScore: qualityScore,
                lastUsed: lastUsed,
                discoveredAt: discoveredAt,
                expiresAt: expiresAt,
              ),
          createCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                required String destinationPeerId,
                required String nextHopPeerId,
                required int hopCount,
                Value<double> qualityScore = const Value.absent(),
                required DateTime lastUsed,
                required DateTime discoveredAt,
                required DateTime expiresAt,
              }) => MeshRoutesCompanion.insert(
                id: id,
                destinationPeerId: destinationPeerId,
                nextHopPeerId: nextHopPeerId,
                hopCount: hopCount,
                qualityScore: qualityScore,
                lastUsed: lastUsed,
                discoveredAt: discoveredAt,
                expiresAt: expiresAt,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$MeshRoutesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $MeshRoutesTable,
      MeshRouteEntity,
      $$MeshRoutesTableFilterComposer,
      $$MeshRoutesTableOrderingComposer,
      $$MeshRoutesTableAnnotationComposer,
      $$MeshRoutesTableCreateCompanionBuilder,
      $$MeshRoutesTableUpdateCompanionBuilder,
      (
        MeshRouteEntity,
        BaseReferences<_$AppDatabase, $MeshRoutesTable, MeshRouteEntity>,
      ),
      MeshRouteEntity,
      PrefetchHooks Function()
    >;
typedef $$MeshMessageQueueTableCreateCompanionBuilder =
    MeshMessageQueueCompanion Function({
      required String messageId,
      required String recipientPeerId,
      required String encryptedPacket,
      required DateTime queuedAt,
      Value<int> retryCount,
      Value<DateTime?> lastRetryAt,
      required DateTime expiresAt,
      Value<int> rowid,
    });
typedef $$MeshMessageQueueTableUpdateCompanionBuilder =
    MeshMessageQueueCompanion Function({
      Value<String> messageId,
      Value<String> recipientPeerId,
      Value<String> encryptedPacket,
      Value<DateTime> queuedAt,
      Value<int> retryCount,
      Value<DateTime?> lastRetryAt,
      Value<DateTime> expiresAt,
      Value<int> rowid,
    });

class $$MeshMessageQueueTableFilterComposer
    extends Composer<_$AppDatabase, $MeshMessageQueueTable> {
  $$MeshMessageQueueTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get messageId => $composableBuilder(
    column: $table.messageId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get recipientPeerId => $composableBuilder(
    column: $table.recipientPeerId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get encryptedPacket => $composableBuilder(
    column: $table.encryptedPacket,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get queuedAt => $composableBuilder(
    column: $table.queuedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get retryCount => $composableBuilder(
    column: $table.retryCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastRetryAt => $composableBuilder(
    column: $table.lastRetryAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get expiresAt => $composableBuilder(
    column: $table.expiresAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$MeshMessageQueueTableOrderingComposer
    extends Composer<_$AppDatabase, $MeshMessageQueueTable> {
  $$MeshMessageQueueTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get messageId => $composableBuilder(
    column: $table.messageId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get recipientPeerId => $composableBuilder(
    column: $table.recipientPeerId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get encryptedPacket => $composableBuilder(
    column: $table.encryptedPacket,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get queuedAt => $composableBuilder(
    column: $table.queuedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get retryCount => $composableBuilder(
    column: $table.retryCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastRetryAt => $composableBuilder(
    column: $table.lastRetryAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get expiresAt => $composableBuilder(
    column: $table.expiresAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$MeshMessageQueueTableAnnotationComposer
    extends Composer<_$AppDatabase, $MeshMessageQueueTable> {
  $$MeshMessageQueueTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get messageId =>
      $composableBuilder(column: $table.messageId, builder: (column) => column);

  GeneratedColumn<String> get recipientPeerId => $composableBuilder(
    column: $table.recipientPeerId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get encryptedPacket => $composableBuilder(
    column: $table.encryptedPacket,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get queuedAt =>
      $composableBuilder(column: $table.queuedAt, builder: (column) => column);

  GeneratedColumn<int> get retryCount => $composableBuilder(
    column: $table.retryCount,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get lastRetryAt => $composableBuilder(
    column: $table.lastRetryAt,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get expiresAt =>
      $composableBuilder(column: $table.expiresAt, builder: (column) => column);
}

class $$MeshMessageQueueTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $MeshMessageQueueTable,
          MeshMessageQueueEntity,
          $$MeshMessageQueueTableFilterComposer,
          $$MeshMessageQueueTableOrderingComposer,
          $$MeshMessageQueueTableAnnotationComposer,
          $$MeshMessageQueueTableCreateCompanionBuilder,
          $$MeshMessageQueueTableUpdateCompanionBuilder,
          (
            MeshMessageQueueEntity,
            BaseReferences<
              _$AppDatabase,
              $MeshMessageQueueTable,
              MeshMessageQueueEntity
            >,
          ),
          MeshMessageQueueEntity,
          PrefetchHooks Function()
        > {
  $$MeshMessageQueueTableTableManager(
    _$AppDatabase db,
    $MeshMessageQueueTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$MeshMessageQueueTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$MeshMessageQueueTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$MeshMessageQueueTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> messageId = const Value.absent(),
                Value<String> recipientPeerId = const Value.absent(),
                Value<String> encryptedPacket = const Value.absent(),
                Value<DateTime> queuedAt = const Value.absent(),
                Value<int> retryCount = const Value.absent(),
                Value<DateTime?> lastRetryAt = const Value.absent(),
                Value<DateTime> expiresAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => MeshMessageQueueCompanion(
                messageId: messageId,
                recipientPeerId: recipientPeerId,
                encryptedPacket: encryptedPacket,
                queuedAt: queuedAt,
                retryCount: retryCount,
                lastRetryAt: lastRetryAt,
                expiresAt: expiresAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String messageId,
                required String recipientPeerId,
                required String encryptedPacket,
                required DateTime queuedAt,
                Value<int> retryCount = const Value.absent(),
                Value<DateTime?> lastRetryAt = const Value.absent(),
                required DateTime expiresAt,
                Value<int> rowid = const Value.absent(),
              }) => MeshMessageQueueCompanion.insert(
                messageId: messageId,
                recipientPeerId: recipientPeerId,
                encryptedPacket: encryptedPacket,
                queuedAt: queuedAt,
                retryCount: retryCount,
                lastRetryAt: lastRetryAt,
                expiresAt: expiresAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$MeshMessageQueueTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $MeshMessageQueueTable,
      MeshMessageQueueEntity,
      $$MeshMessageQueueTableFilterComposer,
      $$MeshMessageQueueTableOrderingComposer,
      $$MeshMessageQueueTableAnnotationComposer,
      $$MeshMessageQueueTableCreateCompanionBuilder,
      $$MeshMessageQueueTableUpdateCompanionBuilder,
      (
        MeshMessageQueueEntity,
        BaseReferences<
          _$AppDatabase,
          $MeshMessageQueueTable,
          MeshMessageQueueEntity
        >,
      ),
      MeshMessageQueueEntity,
      PrefetchHooks Function()
    >;
typedef $$MeshSeenMessagesTableCreateCompanionBuilder =
    MeshSeenMessagesCompanion Function({
      required String messageId,
      required DateTime seenAt,
      required DateTime expiresAt,
      Value<int> rowid,
    });
typedef $$MeshSeenMessagesTableUpdateCompanionBuilder =
    MeshSeenMessagesCompanion Function({
      Value<String> messageId,
      Value<DateTime> seenAt,
      Value<DateTime> expiresAt,
      Value<int> rowid,
    });

class $$MeshSeenMessagesTableFilterComposer
    extends Composer<_$AppDatabase, $MeshSeenMessagesTable> {
  $$MeshSeenMessagesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get messageId => $composableBuilder(
    column: $table.messageId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get seenAt => $composableBuilder(
    column: $table.seenAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get expiresAt => $composableBuilder(
    column: $table.expiresAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$MeshSeenMessagesTableOrderingComposer
    extends Composer<_$AppDatabase, $MeshSeenMessagesTable> {
  $$MeshSeenMessagesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get messageId => $composableBuilder(
    column: $table.messageId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get seenAt => $composableBuilder(
    column: $table.seenAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get expiresAt => $composableBuilder(
    column: $table.expiresAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$MeshSeenMessagesTableAnnotationComposer
    extends Composer<_$AppDatabase, $MeshSeenMessagesTable> {
  $$MeshSeenMessagesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get messageId =>
      $composableBuilder(column: $table.messageId, builder: (column) => column);

  GeneratedColumn<DateTime> get seenAt =>
      $composableBuilder(column: $table.seenAt, builder: (column) => column);

  GeneratedColumn<DateTime> get expiresAt =>
      $composableBuilder(column: $table.expiresAt, builder: (column) => column);
}

class $$MeshSeenMessagesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $MeshSeenMessagesTable,
          MeshSeenMessageEntity,
          $$MeshSeenMessagesTableFilterComposer,
          $$MeshSeenMessagesTableOrderingComposer,
          $$MeshSeenMessagesTableAnnotationComposer,
          $$MeshSeenMessagesTableCreateCompanionBuilder,
          $$MeshSeenMessagesTableUpdateCompanionBuilder,
          (
            MeshSeenMessageEntity,
            BaseReferences<
              _$AppDatabase,
              $MeshSeenMessagesTable,
              MeshSeenMessageEntity
            >,
          ),
          MeshSeenMessageEntity,
          PrefetchHooks Function()
        > {
  $$MeshSeenMessagesTableTableManager(
    _$AppDatabase db,
    $MeshSeenMessagesTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$MeshSeenMessagesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$MeshSeenMessagesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$MeshSeenMessagesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> messageId = const Value.absent(),
                Value<DateTime> seenAt = const Value.absent(),
                Value<DateTime> expiresAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => MeshSeenMessagesCompanion(
                messageId: messageId,
                seenAt: seenAt,
                expiresAt: expiresAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String messageId,
                required DateTime seenAt,
                required DateTime expiresAt,
                Value<int> rowid = const Value.absent(),
              }) => MeshSeenMessagesCompanion.insert(
                messageId: messageId,
                seenAt: seenAt,
                expiresAt: expiresAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$MeshSeenMessagesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $MeshSeenMessagesTable,
      MeshSeenMessageEntity,
      $$MeshSeenMessagesTableFilterComposer,
      $$MeshSeenMessagesTableOrderingComposer,
      $$MeshSeenMessagesTableAnnotationComposer,
      $$MeshSeenMessagesTableCreateCompanionBuilder,
      $$MeshSeenMessagesTableUpdateCompanionBuilder,
      (
        MeshSeenMessageEntity,
        BaseReferences<
          _$AppDatabase,
          $MeshSeenMessagesTable,
          MeshSeenMessageEntity
        >,
      ),
      MeshSeenMessageEntity,
      PrefetchHooks Function()
    >;
typedef $$RallyChannelMembersTableCreateCompanionBuilder =
    RallyChannelMembersCompanion Function({
      Value<int> id,
      required String channelId,
      required String userId,
      required String displayName,
      required String identityType,
      required DateTime joinedAt,
      required DateTime lastSeenAt,
      Value<int> messageCount,
      Value<int> reputationScore,
    });
typedef $$RallyChannelMembersTableUpdateCompanionBuilder =
    RallyChannelMembersCompanion Function({
      Value<int> id,
      Value<String> channelId,
      Value<String> userId,
      Value<String> displayName,
      Value<String> identityType,
      Value<DateTime> joinedAt,
      Value<DateTime> lastSeenAt,
      Value<int> messageCount,
      Value<int> reputationScore,
    });

final class $$RallyChannelMembersTableReferences
    extends
        BaseReferences<
          _$AppDatabase,
          $RallyChannelMembersTable,
          RallyChannelMemberEntity
        > {
  $$RallyChannelMembersTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $ConversationsTable _channelIdTable(_$AppDatabase db) =>
      db.conversations.createAlias(
        $_aliasNameGenerator(
          db.rallyChannelMembers.channelId,
          db.conversations.id,
        ),
      );

  $$ConversationsTableProcessedTableManager get channelId {
    final $_column = $_itemColumn<String>('channel_id')!;

    final manager = $$ConversationsTableTableManager(
      $_db,
      $_db.conversations,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_channelIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$RallyChannelMembersTableFilterComposer
    extends Composer<_$AppDatabase, $RallyChannelMembersTable> {
  $$RallyChannelMembersTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get userId => $composableBuilder(
    column: $table.userId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get displayName => $composableBuilder(
    column: $table.displayName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get identityType => $composableBuilder(
    column: $table.identityType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get joinedAt => $composableBuilder(
    column: $table.joinedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastSeenAt => $composableBuilder(
    column: $table.lastSeenAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get messageCount => $composableBuilder(
    column: $table.messageCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get reputationScore => $composableBuilder(
    column: $table.reputationScore,
    builder: (column) => ColumnFilters(column),
  );

  $$ConversationsTableFilterComposer get channelId {
    final $$ConversationsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.channelId,
      referencedTable: $db.conversations,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ConversationsTableFilterComposer(
            $db: $db,
            $table: $db.conversations,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$RallyChannelMembersTableOrderingComposer
    extends Composer<_$AppDatabase, $RallyChannelMembersTable> {
  $$RallyChannelMembersTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get userId => $composableBuilder(
    column: $table.userId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get displayName => $composableBuilder(
    column: $table.displayName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get identityType => $composableBuilder(
    column: $table.identityType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get joinedAt => $composableBuilder(
    column: $table.joinedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastSeenAt => $composableBuilder(
    column: $table.lastSeenAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get messageCount => $composableBuilder(
    column: $table.messageCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get reputationScore => $composableBuilder(
    column: $table.reputationScore,
    builder: (column) => ColumnOrderings(column),
  );

  $$ConversationsTableOrderingComposer get channelId {
    final $$ConversationsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.channelId,
      referencedTable: $db.conversations,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ConversationsTableOrderingComposer(
            $db: $db,
            $table: $db.conversations,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$RallyChannelMembersTableAnnotationComposer
    extends Composer<_$AppDatabase, $RallyChannelMembersTable> {
  $$RallyChannelMembersTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get userId =>
      $composableBuilder(column: $table.userId, builder: (column) => column);

  GeneratedColumn<String> get displayName => $composableBuilder(
    column: $table.displayName,
    builder: (column) => column,
  );

  GeneratedColumn<String> get identityType => $composableBuilder(
    column: $table.identityType,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get joinedAt =>
      $composableBuilder(column: $table.joinedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get lastSeenAt => $composableBuilder(
    column: $table.lastSeenAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get messageCount => $composableBuilder(
    column: $table.messageCount,
    builder: (column) => column,
  );

  GeneratedColumn<int> get reputationScore => $composableBuilder(
    column: $table.reputationScore,
    builder: (column) => column,
  );

  $$ConversationsTableAnnotationComposer get channelId {
    final $$ConversationsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.channelId,
      referencedTable: $db.conversations,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ConversationsTableAnnotationComposer(
            $db: $db,
            $table: $db.conversations,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$RallyChannelMembersTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $RallyChannelMembersTable,
          RallyChannelMemberEntity,
          $$RallyChannelMembersTableFilterComposer,
          $$RallyChannelMembersTableOrderingComposer,
          $$RallyChannelMembersTableAnnotationComposer,
          $$RallyChannelMembersTableCreateCompanionBuilder,
          $$RallyChannelMembersTableUpdateCompanionBuilder,
          (RallyChannelMemberEntity, $$RallyChannelMembersTableReferences),
          RallyChannelMemberEntity,
          PrefetchHooks Function({bool channelId})
        > {
  $$RallyChannelMembersTableTableManager(
    _$AppDatabase db,
    $RallyChannelMembersTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$RallyChannelMembersTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$RallyChannelMembersTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer: () =>
              $$RallyChannelMembersTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                Value<String> channelId = const Value.absent(),
                Value<String> userId = const Value.absent(),
                Value<String> displayName = const Value.absent(),
                Value<String> identityType = const Value.absent(),
                Value<DateTime> joinedAt = const Value.absent(),
                Value<DateTime> lastSeenAt = const Value.absent(),
                Value<int> messageCount = const Value.absent(),
                Value<int> reputationScore = const Value.absent(),
              }) => RallyChannelMembersCompanion(
                id: id,
                channelId: channelId,
                userId: userId,
                displayName: displayName,
                identityType: identityType,
                joinedAt: joinedAt,
                lastSeenAt: lastSeenAt,
                messageCount: messageCount,
                reputationScore: reputationScore,
              ),
          createCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                required String channelId,
                required String userId,
                required String displayName,
                required String identityType,
                required DateTime joinedAt,
                required DateTime lastSeenAt,
                Value<int> messageCount = const Value.absent(),
                Value<int> reputationScore = const Value.absent(),
              }) => RallyChannelMembersCompanion.insert(
                id: id,
                channelId: channelId,
                userId: userId,
                displayName: displayName,
                identityType: identityType,
                joinedAt: joinedAt,
                lastSeenAt: lastSeenAt,
                messageCount: messageCount,
                reputationScore: reputationScore,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$RallyChannelMembersTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({channelId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (channelId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.channelId,
                                referencedTable:
                                    $$RallyChannelMembersTableReferences
                                        ._channelIdTable(db),
                                referencedColumn:
                                    $$RallyChannelMembersTableReferences
                                        ._channelIdTable(db)
                                        .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$RallyChannelMembersTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $RallyChannelMembersTable,
      RallyChannelMemberEntity,
      $$RallyChannelMembersTableFilterComposer,
      $$RallyChannelMembersTableOrderingComposer,
      $$RallyChannelMembersTableAnnotationComposer,
      $$RallyChannelMembersTableCreateCompanionBuilder,
      $$RallyChannelMembersTableUpdateCompanionBuilder,
      (RallyChannelMemberEntity, $$RallyChannelMembersTableReferences),
      RallyChannelMemberEntity,
      PrefetchHooks Function({bool channelId})
    >;
typedef $$RallyReportsTableCreateCompanionBuilder =
    RallyReportsCompanion Function({
      Value<int> id,
      required String reporterId,
      required String reportedUserId,
      Value<String?> messageId,
      required String category,
      Value<String?> notes,
      required DateTime reportedAt,
      Value<bool> isUploaded,
    });
typedef $$RallyReportsTableUpdateCompanionBuilder =
    RallyReportsCompanion Function({
      Value<int> id,
      Value<String> reporterId,
      Value<String> reportedUserId,
      Value<String?> messageId,
      Value<String> category,
      Value<String?> notes,
      Value<DateTime> reportedAt,
      Value<bool> isUploaded,
    });

class $$RallyReportsTableFilterComposer
    extends Composer<_$AppDatabase, $RallyReportsTable> {
  $$RallyReportsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get reporterId => $composableBuilder(
    column: $table.reporterId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get reportedUserId => $composableBuilder(
    column: $table.reportedUserId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get messageId => $composableBuilder(
    column: $table.messageId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get category => $composableBuilder(
    column: $table.category,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get reportedAt => $composableBuilder(
    column: $table.reportedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isUploaded => $composableBuilder(
    column: $table.isUploaded,
    builder: (column) => ColumnFilters(column),
  );
}

class $$RallyReportsTableOrderingComposer
    extends Composer<_$AppDatabase, $RallyReportsTable> {
  $$RallyReportsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get reporterId => $composableBuilder(
    column: $table.reporterId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get reportedUserId => $composableBuilder(
    column: $table.reportedUserId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get messageId => $composableBuilder(
    column: $table.messageId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get category => $composableBuilder(
    column: $table.category,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get reportedAt => $composableBuilder(
    column: $table.reportedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isUploaded => $composableBuilder(
    column: $table.isUploaded,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$RallyReportsTableAnnotationComposer
    extends Composer<_$AppDatabase, $RallyReportsTable> {
  $$RallyReportsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get reporterId => $composableBuilder(
    column: $table.reporterId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get reportedUserId => $composableBuilder(
    column: $table.reportedUserId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get messageId =>
      $composableBuilder(column: $table.messageId, builder: (column) => column);

  GeneratedColumn<String> get category =>
      $composableBuilder(column: $table.category, builder: (column) => column);

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<DateTime> get reportedAt => $composableBuilder(
    column: $table.reportedAt,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isUploaded => $composableBuilder(
    column: $table.isUploaded,
    builder: (column) => column,
  );
}

class $$RallyReportsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $RallyReportsTable,
          RallyReportEntity,
          $$RallyReportsTableFilterComposer,
          $$RallyReportsTableOrderingComposer,
          $$RallyReportsTableAnnotationComposer,
          $$RallyReportsTableCreateCompanionBuilder,
          $$RallyReportsTableUpdateCompanionBuilder,
          (
            RallyReportEntity,
            BaseReferences<
              _$AppDatabase,
              $RallyReportsTable,
              RallyReportEntity
            >,
          ),
          RallyReportEntity,
          PrefetchHooks Function()
        > {
  $$RallyReportsTableTableManager(_$AppDatabase db, $RallyReportsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$RallyReportsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$RallyReportsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$RallyReportsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                Value<String> reporterId = const Value.absent(),
                Value<String> reportedUserId = const Value.absent(),
                Value<String?> messageId = const Value.absent(),
                Value<String> category = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<DateTime> reportedAt = const Value.absent(),
                Value<bool> isUploaded = const Value.absent(),
              }) => RallyReportsCompanion(
                id: id,
                reporterId: reporterId,
                reportedUserId: reportedUserId,
                messageId: messageId,
                category: category,
                notes: notes,
                reportedAt: reportedAt,
                isUploaded: isUploaded,
              ),
          createCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                required String reporterId,
                required String reportedUserId,
                Value<String?> messageId = const Value.absent(),
                required String category,
                Value<String?> notes = const Value.absent(),
                required DateTime reportedAt,
                Value<bool> isUploaded = const Value.absent(),
              }) => RallyReportsCompanion.insert(
                id: id,
                reporterId: reporterId,
                reportedUserId: reportedUserId,
                messageId: messageId,
                category: category,
                notes: notes,
                reportedAt: reportedAt,
                isUploaded: isUploaded,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$RallyReportsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $RallyReportsTable,
      RallyReportEntity,
      $$RallyReportsTableFilterComposer,
      $$RallyReportsTableOrderingComposer,
      $$RallyReportsTableAnnotationComposer,
      $$RallyReportsTableCreateCompanionBuilder,
      $$RallyReportsTableUpdateCompanionBuilder,
      (
        RallyReportEntity,
        BaseReferences<_$AppDatabase, $RallyReportsTable, RallyReportEntity>,
      ),
      RallyReportEntity,
      PrefetchHooks Function()
    >;

class $AppDatabaseManager {
  final _$AppDatabase _db;
  $AppDatabaseManager(this._db);
  $$ContactsTableTableManager get contacts =>
      $$ContactsTableTableManager(_db, _db.contacts);
  $$ConversationsTableTableManager get conversations =>
      $$ConversationsTableTableManager(_db, _db.conversations);
  $$MessagesTableTableManager get messages =>
      $$MessagesTableTableManager(_db, _db.messages);
  $$GroupMembersTableTableManager get groupMembers =>
      $$GroupMembersTableTableManager(_db, _db.groupMembers);
  $$MeshPeersTableTableManager get meshPeers =>
      $$MeshPeersTableTableManager(_db, _db.meshPeers);
  $$MeshRoutesTableTableManager get meshRoutes =>
      $$MeshRoutesTableTableManager(_db, _db.meshRoutes);
  $$MeshMessageQueueTableTableManager get meshMessageQueue =>
      $$MeshMessageQueueTableTableManager(_db, _db.meshMessageQueue);
  $$MeshSeenMessagesTableTableManager get meshSeenMessages =>
      $$MeshSeenMessagesTableTableManager(_db, _db.meshSeenMessages);
  $$RallyChannelMembersTableTableManager get rallyChannelMembers =>
      $$RallyChannelMembersTableTableManager(_db, _db.rallyChannelMembers);
  $$RallyReportsTableTableManager get rallyReports =>
      $$RallyReportsTableTableManager(_db, _db.rallyReports);
}
